
#include <stdio.h>
#include <stdlib.h>
//顺子日期 
int main(int argc, char *argv[])
{
  int sum=0,m,d,dmax;
  for(m=1;m<=12;m++)//用循环添加数据：月份
  {
    if(m==2)//2022不是闰年，所以28
    {
      dmax=28;
    }
    if(m==1||m==3||m==5||m==7||m==8||m==10||m==12)//用if限定最高日期先
    {
      dmax=31;
    }
    if(m==4||m==6||m==9||m==11)
    {
      dmax=30;
    }
    for(d=1;d<=dmax;d++)//添加日期，遵循从大到小，小数据优先遍历
    {  //这一块是前三个的数字比对          这一块是后三个数字的比对
      if((m/10==(m%10)-1&&m%10==(d/10)-1)||(m%10==(d/10)-1&&d/10==(d%10)-1))
      //又忘了这个技巧，取整取模来拆分数据，我们不必想着输入一个数字，只要拿一个个数字比对就行了
      //减一就是为了和上一个数字相等，假设拿01/23来讲，我们划为两部分讨论，第一是012这三个数字
      //再就是123，显然都成立。要分开这三个数字，就拿取整取模比对就可以了
      {
        sum++;
      }
    }
  }
  printf("%d",sum);
  return 0;
}


//#define _CRT_SECURE_NO_WARNINGS
//
//#include<stdio.h>
//int main()
//{
//	int a, b, n;
//	int m = 0;
//	float x;
//	scanf("%d%d%d", &a, &b, &n);
//	x = n / (5.00 * a + 2.00 * b);//保留两位足以
//	if (x > (int)x)
//	{
//		x = (int)x + 1;
//	}
//	else
//	{
//		x = (int)x;
//	}
//	if (n - ((int)x - 1) * (5 * a + 2 * b) <=5*a)//仔细啊逻辑！别让整数僵化你的思维
//	{
//		while (a * m <= n - ((int)x - 1) * (5 * a + 2 * b))
//		{
//			m++;
//		}
//	}
//	else
//	{
//		while (5*a + b*m <= n - ((int)x - 1) * (5 * a + 2 * b))
//		{
//			m++;
//		}
//	}
//	int sum = ((int)x - 1) * 7 + m;
//	printf("%d", sum);
//
//
//	return 0;
//}
////63分，还有三分之一错的
////总结一下：1，赋值不是打印，2.不要把一个数据的结果来直接用，一定要注意，是未知量就直接用未知量，
//
////改进学习
#include<stdio.h>
int main()
{
	long a, b, n;
	scanf("%ld %ld %ld", &a, &b, &n);
	if (n % (5 * a + 2 * b) == 0)//当n能够整除5*a + 2*b（七天）时
		printf("%ld", (n / (5 * a + 2 * b)) * 7 + 0);
	else if (n % (5 * a + 2 * b) <= a)//当n能够整除（七天）然后剩下的题少于或者等于一天时 
		printf("%ld", (n / (5 * a + 2 * b)) * 7 + 1);
	else if (n % (5 * a + 2 * b) <= 2 * a)//以此类推
		printf("%ld", (n / (5 * a + 2 * b)) * 7 + 2);
	else if (n % (5 * a + 2 * b) <= 3 * a)
		printf("%ld", (n / (5 * a + 2 * b)) * 7 + 3);
	else if (n % (5 * a + 2 * b) <= 4 * a)
		printf("%ld", (n / (5 * a + 2 * b)) * 7 + 4);
	else if (n % (5 * a + 2 * b) <= 5 * a)
		printf("%ld", (n / (5 * a + 2 * b)) * 7 + 5);
	else if (n % (5 * a + 2 * b) <= 5 * a + b)
		printf("%ld", (n / (5 * a + 2 * b)) * 7 + 6);
	else //最后这种情况需要去掉等于 
		printf("%ld", (n / (5 * a + 2 * b)) * 7 + 7);//这是不满七天的量但要七天的
	return 0;
}

////2.用取模的方法表示还剩最后一个星期时几天的题量分别讨论，
////用取整的方法来记录有整的几个星期，不够的就单独加一天两天以此类推


#include<stdio.h>//修剪灌木
#include<stdlib.h>

//总结:1.分奇偶讨论，决定中间的数据要不要打印
//2.研究规律，总结普遍规律
//3.根据对称性质，打印一半倒过来打印就行了
//4.注意你的公式是从1还是0开始，还有注意核对循环条件是否没问题
int main()
{
	long n,i,middle;
	scanf("%ld",&n);

	if(n%2!=0)
	{
		middle=(1+n)/2;
		for(i=1;i<=middle;i++)
		     {
			 	printf("%ld\n",(n-1)*2-2*(i-1));//你这个式子是1开始的所以循环改1
			 }
			 
			 for(i=middle-1;0<i;i--)//奇数时另一边的middle不打印
			 {
			 printf("%ld\n",(n-1)*2-2*(i-1));
			 }
			 
		
	}
	
	else
	{
		middle=n/2;
			for(i=1;i<=middle;i++)
					     {
						 	printf("%ld\n",(n-1)*2-2*(i-1));
						 }
						 
						 for(i=middle;0<i;i--)
						 {
						 printf("%ld\n",(n-1)*2-2*(i-1));
						 }
					 
	}
	
	
	return 0;
}





//1：如何是使得差值最小呢，我们可以利用dp的思想，要使得整体最小，那么组成他的各个部分也是最小，那么问题就变成了，如何使得各个部分的值最小；
//   2：每个部分有对应位上的差值组成，那么，要使得这个差值乘的进制数尽可能小就可以了；
//   3：如何使得进制尽可能小呢，进制的区间在2~N之间，那么只需要在这个区间之内，选取能包含a[i]和b[i]两个值的最小进制值就ok了，至此，思路就出来了

//如 1           3          2
//第三数位  第二数位    最低数位
#include<stdio.h>
int a[100005]={0};//转码可能数据很大
int b[100005]={0};
int mod=1000000007;
int max(int a,int b)
{
	return (a>b?a:b);
}

int main()
{
    int Ma,Mb,N,i;//其实N是有用的，只是测试数据没有非法数据，完整的话还要加判断输入是否非法才行的
    scanf("%d%d",&N,&Ma);
    for(i=Ma;i>=1;i--)
    //倒序打印是因为开头输入最高位数，数组下标和位数匹配好理解，至于1也是，舍去了0下标
    {
		scanf("%d",&a[i]);
		//又开始不写&
	}
	 scanf("%d",&Mb);
	    for(i=Mb;i>=1;i--)
	    {
			scanf("%d",&b[i]);
		}
		int jz[100005]={0};
		for(i=Ma;i>=1;i--)
	{
		jz[i]=max(max(a[i]+1,b[i]+1),2);//选取最小进制
		//选取最大的进制是因为A与B同进制，因此两者数据间只有选最大的那个数据才能保证两者相同
		//而题目意思中的十进制输入只是我们认为输入的数据，但是题设中的意思是我们实际上不知道它是什么进制
		//而为了所求相减最小，我们就选最小的进制，也就是保证两者相同时选择最小的进制，也就是加1.
		//加1是因为如果仅仅赋值输入的数据不可能的，注意有进位这个东西，不加1数据早就进位了
	}	
	long long sum=0;//数据大用长字符
     for(i=Ma;i>=2;i--)
     {
//	 	sum+=((sum+a[i]-b[i])*jz[i-1])%mod;
       sum=((sum+a[i]-b[i])*jz[i-1])%mod;
       //意思是将最高位的数据一直往低位转换，往上进就除自身的进制，往下进就乘低一位的进制
       //i到2截至是因为最低进位时不需要乘进制，单独讨论。
       //sum也要放进去参与进位是因为首先是循环，上一次的sum的数据也在这次的循环中，而上一次sum的数据当然也要一同参与进位
       //还有就是输入数据是分每一个进位而不是连成一起，因此要循环检测各个数位来转换进制，同时也要将前面的数据相加和继续转码！
       //据题设的理解，认为是每转换一次进制就要取一次模才能成功转化进位
       //不是很清楚，希望明白的大佬说一下
	 	//(+=)不等于(=),如1被赋值为3，和1加上3是不同的！
	 }
		sum+=(a[1]-b[1]);//最低位时直接导入数据
		sum%=mod;//转化进制
		printf("%lld\n",sum);
		
		return 0;
		
		
}

//首先，注意子矩阵是输入进数据的一部分
//输入进的数据位置是不能变的，是在这个固定的矩阵中选取其中小的矩阵！
//而不是输入进入数据然后随机排列！

//本文以示例数据作为参考
#include<stdio.h>
#include<stdlib.h>
int s[505][505];
int main()
{
	int n,m,k;
	 scanf("%d%d%d",&n,&m,&k);
	 for(int i=1;i<=n;i++)
	 {
	 	for(int j=1;j<=m;j++)
	 	{
		 	scanf("%d",&s[i][j]);
		 	s[i][j]+=s[i-1][j];
		 	//双循环插入数据，
		 	//加上前面的是因为相当于选取上下的矩阵使用，
       //每一次都加上前面行数据的总和.
       //每一个对应行数的数组数据都是当前行加前面所有行数的总和
       //前缀和的思想


       //这么写的好处就是不会超时，因为选中想要的数据都可以通过加减的运算直接得出
       //我就不需要自己开n个循环自己去截取，这样会显得很麻烦而且必定超时

		 }
	 }         
	 
	 long long int res=0;//长整型防止数据过大溢出
	 //long long 是其简写;
   
   
	 for(int i=1;i<=n;i++)//选定截断的子矩阵范围
	
	 {
	 	for(int j=i;j<=n;j++)//选定所需的子矩阵范围
		 //条件注意看清楚不要乱写！
		 
		 //两个循环就相当于，先选定第一行开始选取行数，然后跟同时选第一二，第一二三,.....行一起选择
//(因为前面的数组每次都把前面数组的数据都加了起来，所以每次下一行的数组的数据都是前面
   //行对应列的数据之和)
    //然后再从第二行开始,跟着同时选二三，二三四,.....行一起
		
		 
	   {
	   	for(int left=1,right=1,sum=0;right<=m;right++)//是<=！
       //每一轮sum都会重置一次,sum的范围只在单次选定的行数中

       //right++既是推进遍历，又是一种默认，只要这层left不增
       //就相当于这个数据可行，所以就要加1，而如果left增加
       //说明当前sum太大，我就要舍弃最左边的数，要看当前数有多大，
       //来决定减少最左边数据的多少,即left增多少
       
       
	   	//right记录增加，left记录舍去，sum作为判断是否能同时选取多少个数，res为最终多少个矩阵
	   	//原理就是选取和舍去，如从1开始，满足条件，记为1，然后加上2同样不超过，所以继续记录，此时res等于三是因为，这两个数据现在是同时可以选中，因此分别
	   	//为单独的1和2，以及1和2一起成为一个矩阵的三种情况，后面的3，4也是选取不同子矩阵成为十种。
       //举例如1,2,3中可以有1,2/2,3/1,2,3三种(注意要连续才为子矩阵)
       
	   	//而从第二行开始就是同时选取1和5这两个数据和后面的2、6尝试连结，没有超过k就选取新的子矩阵，超过就删去1、5，剩下2、6，继续往下连结，重复操作
	   	//后面第三行就是1，5，9连在一起尝试连结，以此类推
	   	//而后面从第二行单独数据开始时后面同样重复，只是不再选取上一行的数据，从而达到全面查找矩阵的目的，如5，9绑在一起，参考图片。
	   	{
		   		sum+=s[j][right]-s[i-1][right];
           //选取子矩阵大小
			   		   	while(sum>k)
			   		   	{
			   			   	sum-=s[j][left]-s[i-1][left];//这里是去掉最左边无用的数据
			   			   	left++;
                    //减少的个数增加
			   			   	
			   			   }
//			   			   res+=right-left+1;可读性差
			   			   res+=right-(left-1);
			   			   //这里的加1其实是因为下标问题，因为要用到left作下标，0又没有存放数据只有1开始才有
						//因此不得不给left赋值上1，如果从0开始放数据，其实是res+=right-left;
					
					//而更清楚的展示从1开始应该是res+=right - (left - 1);才更准确
          //(开始的时候不存在舍去的数据)
		            //至于为什么就是找规律

					//一开始从1，2，3，4
			        //得到的结果就有1,3,6,10，显然就是加下一个n即n+1的结果
			        
			        //left是不可能会比right大的
					       //因为right就相当于在右边找数据，left相当于判断是否应该删除
					       //如果sum>k,那么left就会选中在sum中的最左边的数据删除
					       //一直到sum<=k为止，再退出while增加该情况.
					       //最坏的情况也是当前right增加的这个结果，一旦这个结果也被删除
					       //那么sum=0,因此最差也是res+=0,不可能会出现倒减
					       //而删除就是减少选取新的子矩阵的情况，意思就是有数据不能在这个排列中了
					       //要删去，根据子矩阵的选取，也就是删除最左边的，也只能舍去最左边的
					       //(子矩阵需要不间断)
					
//总结：	left和right相当于划定边界，在这之间范围内的数可以选取的子矩阵。
//	right一直往前走left紧跟着。只要sum大于k,left也往右移缩小范围，left和right都是两用，下标和划定数的数量范围
//right一直都是往前走的，left也有可能会删除，所以确保了每次选取的数都是新的，因此每一轮都要加上right-(left-1);
//          
          
				
		   }
		   
		   	
		   }
	   	
	   
		

	 }
	 printf("%lld",res);
	 
	 
	                 
	
	
	return 0;
}



#include<stdio.h>
#include<stdlib.h>
int dp[10000005];
#define mod 1000000007
//不需要类型

//*分析：一开始想的是二维情况，就很难联想，甚至复杂许多，所以我们可以转化为一维思想，这样思考起来就轻松很多
//我们可以把两个单位面积看成一个，所以三个就是1.5个单位面积，再把画布变为1*N的模式，这样就很好解决了

//还有题设案例可以看出，不同颜色不同位置同形态摆放是不算的，问的是每个方块用不重复的形态摆放才成立
//注意是每个方块不重复的形态，只要有一个方块跟自己之前是不一样的没有出现过的形态都算
//（如横或者竖，不同方块随机的横竖只要不重复，拼好画布，都算成立)

int main()
{
int n;
scanf("%d",&n);
dp[1]=1,dp[2]=2,dp[3]=5;
//先导入2维的正确数据，因为本质上1维和2维的方式是不同的，
//只是我们给了2维的一个1维的环境。
for(int i=4;i<=n;i++)
{
	dp[i]=(dp[i-1]*2%mod+dp[i-3]*1%mod)%mod;//数据大就多取模
	//对于规律题目，就需要用上循环以及递推公式的思想
	//定单个方块情况为A，两个1.5情况为B
	//导入前三个数据后，现在我们一维的角度思考问题
	//分两种情况，单用一个单位面积的方块或者用2个1.5单位面积(因为1.5必须一次用两个才能补满）
	//dp是方法种类，因为A方块中放置同样的位置，在二维矩阵是不同的，有两种摆放方式
     //但是B在矩阵中都是占满高度的，所以只有一种摆放方式。
     //因为是一维，只有一行，根据(*分析)可以判断一维中两种方块交错着摆放还是统一摆放都是一致的
     
     //重点在于只要出现了一个积木它本身从来没有出现过的状态就算一种
     //所以不妨我们直接分为全部为一个方块和2个1.5面积的方块讨论
     //如四个方块的全部种类，A情况（i-1）就是三个方块的总情况*2
     //(因为单个方块有两种摆放方式所以2*2*2*2=dp[i-1]*2;
     //而B(i-3)只有一种摆放方式，故乘*1，类比A情况.
     //就单纯的用一维的角度看这个问题就行了，把dp[i-1]当作前面全是A的方块，把dp[i-3]当作全是B，
	 //剩下的带入二维的数据就变成二维了

   //核心就是一维中可以忽视它的形态变换，如条形积木，一个积木没有多种形态可言
   //把它当作一个小的整体,把三个积木也想象成一维下压缩成一个只有一种形态
   //的样子，但是要注意有没有特殊情况.如条形积木本身形态不同摆放
   //会影响结果.
   
}
	   printf("%d\n",dp[n]);
		

	 
	                 
	
	
	return 0;
}
//总结：用一维思想简化对二维的不同形态的讨论
//(仅用讨论I型方块的不同高度形态摆放即可，将复杂问题简化实现

#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>

int  main()
{     int a[10000][10]={0};//雷
int b[10000][10]={0};//排雷

	  int n,m,count=0;
	   scanf("%d%d",&n,&m);
	   for(int i=1;i<=n;i++)
	   {
	   	for(int j=1;j<=3;j++)
	   	{
		   	scanf("%d",&a[i][j]);
		   }
	   }
		
for(int i=1;i<=m;i++)
	   {
	   	for(int j=1;j<=3;j++)
	   	{
		   	scanf("%d",&b[i][j]);
		   }
	   }
	   
	 for(int k=1;k<=m;k++)  
	 {
	 	for(int i=1;i<=n;i++)//这个需要每一个雷区的认真排查，你把循环逻辑想清楚，不要靠记忆！
		 	   {
					if(a[i][4]!=1)
		 	   {
//						if((a[i][1]-b[i][1])*(a[i][1]-b[i][1])+(a[i][2]-b[i][2])*(a[i][2]-b[i][2])<=(b[k][3]*b[k][3]))
                      if((a[i][1]-b[k][1])*(a[i][1]-b[k][1])+(a[i][2]-b[k][2])*(a[i][2]-b[k][2])<=(b[k][3]*b[k][3]))
                      //对应排雷和它的半径想好再写
							 	   	{
											count++;
											a[i][4]=1;//标记
										}
				}
		 	   
		 	   }
	 }
	 
	 //自爆
	          for(int i=1;i<=n;i++)//不认真分析乱写全错,用定一动一法则
	          {
			  		for(int j=i;j<n;j++)//单个循环无法满足全程遍历，应该用双循环,不需要等于N，不然会溢出,因为下面是i+1
			  		//又开始条件乱写
				  	 		 	   {//是i不是j！
				  	 		 	   	if(a[i][4]!=a[j+1][4])//没爆和都爆了都不需要考虑了,而不相等就肯定可能使得另外一个爆
				  	 		 	   	{
										   	if((a[i][1]-a[j+1][1])*(a[i][1]-a[j+1][1])+(a[i][2]-a[j+1][2])*(a[i][2]-a[j+1][2])<=a[i][3]*a[i][3]||(a[i][1]-a[j+1][1])*(a[i][1]-a[j+1][1])+(a[i][2]-a[j+1][2])*(a[i][2]-a[j+1][2])<=a[j+1][3]*a[j+1][3])
											   		 	   	//你看等于号又不写了，拜托关键步骤认真一点行不行？
																   {
											   						count++;
                                     a[i][4]=1;
                                     a[j+1][4]=1;//标记记录已爆
											   						
											   					}
										   	
										   }
				  	 		 	   
				  	 		 	   }
			  }
	 	 
	 	 
	 	 printf("%d",count);

	return 0;
}
//40分，内存不足，都是运行错误，你的代码正确，
//可能是数组越界了，你的条件设的很多，时间不是问题，应该是爆了空间
//越界出问题了.思路清晰值得赞赏，但是这里就是要解决这个数组问题
//你当然可以开多个数组实现强行放置，但显然不见得高明
//最重要的还是能不能有效利用数组空间--用到哈希算法





//动态规划,迭代

//思路:循环遍历所有情况
//迭代每次分两种情况，要么打酒要么看花分两种考虑
//用a[0][0][2]=1标记为真+迭代
//从而实现在所有情况中给最终结果
//增加有效值.
//迭代时注意设置条件避免输入非法数据
//

#include <stdio.h>//李白打酒
#include <stdlib.h>
#define mod 1000000007
int main(int argc, char *argv[])
{
  //0斗没有意义，因为最后要看花，不可能有0斗遇店
  
  int n,m,i,j,p;//n酒m花
  int a[101][101][101];//根据题设最大来设大小，用三维数组
  a[0][0][2]=1;//初始状态
  //如果在迭代中往前推推不到这个数组的，就一定是非法情况
  //自然数组最终结果为0

  //设1时相当于考虑开始时酒有两斗的情况，只有开始遵循这点才能算一种可能,相当于标记
  scanf("%d%d",&n,&m);

  //题范围为100,三个循环10^(2*3)=10^6够用
  
  for(i=0;i<=n;i++)//打酒
  //打多少次酒情况的遍历
  {
//    for(int j=0;i<=m;j++)//你看又是条件青光眼，真的6
     for(int j=0;j<=m;j++)//花
     //看多少次花情况的遍历
    {
      for(p=0;p<=m;p++)//酒量//循环上限是m是因为酒量和看花次数要相等
      //酒量为多少次情况的遍历
      {
        //打酒还是看花每次循环都分两个分支讨论
        //合法的自然会返回给a[n][m][0]真值
        //不合法自然返回0。
        if(p%2==0&&p>0&&i>0)//打酒
        //因为还需要讨论不打酒的情况，即i=0时
        //0斗就不可能再加酒了
        {
          // a[i][j][p]=(a[i][j][p]%mod)+(a[i-1][j][p/2]%mod);
          a[i][j][p]+=(a[i-1][j][p/2]%mod);
          //这一次情况       上一次
          //迭代
        }
        if(j>0)//看花
        //1开始表示开始看花
        {
          //  a[i][j][p]=(a[i][j][p]%mod)+(a[i][j-1][p+1]%mod);
             a[i][j][p]+=(a[i][j-1][p+1]%mod);
             //这次情况      上次的
          

           //可以直接写+=,因为每次迭代最新的情况即空数组，
           //根本就不存在数据溢出，因此对空数组没必要取模，只用
           //对前面的数组取模即可
           //看一次花少一斗，符合逻辑连接之前的数组，相当于一条线，就为一种情况，
           //要清楚因为循环是递增的，所以左边是后面的情况，右边是前面的情况
           //如a[0][0][2],那么它看花就是a[0][1][1]
           //等于1是标记也是计数，只有一直传下来到达最终的a[n][m][0]就统计为一种情况
           //等于0说明开始时不是两斗酒

           //最典型的就是p%2==0,假如后面的数组为[1][0][3]，推前面为[0][0][1.5]
           //这是不存在的，所以要舍弃,其他同理

           //迭代思想每次都要从前面找答案，随着循环变大才能推出后面的结果
           //因此正常思路也一定是左边是当前最大的结果，右边是前面的结果！
           //想获得最终的答案，那都是要在前面结果的基础才能得出的！

           //满足条件，才进行此次情况的访问，计算这一次的结果，
           //因此放在左边，
           //而要算出，就要使用迭代，就是同样要找前面的结果
           
           
        }
       
      }
    }
  }
  printf("%d",a[n][m][0]);
  //循环遵循从简单到复杂，优先循环最简单的情况最佳
  //多重循环就是为了讨论完所有情况，最后回到a[n][m][0]时
  //就返回之前积累的所有的情况。

  //遍历所有可能，无脑循环查找.不必担心合不合法，不合法自然只会+0
  //a[0][0][2]开始的迭代就已经是合法的前提了！

  //a[n][m][0]表示他一共遇到店 N次, 遇到花 M次。正好把酒喝光了。
  //按照题设操作

  return 0;
}

//卡片
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  int n,sum=0;//n记录多少个数字，sum记录使用1的个数
  for(n=1;;n++)//自增，一直拼数字
  {
    int i=n;//用i来运算，不然n会因为取整输出错误数据
    while(i!=0)
    {
      if(i%10==1)
      {
         sum++;
      } 
      if(sum>2021)
      //取到2022个1时，就把n减一个数字，这样就是最多的数字了
      {
        n--;
        printf("%d",n);
        return 0;//直接return，防止死循环
      }
     i/=10;
    }
    //不断地取整取模实现1个个数位上的数字的比对
  }
  
}


#include <stdio.h>
#include <stdlib.h>

//int main(int argc, char *argv[])
//{
// int sum=0;
// 
// for(int x=0;x<20;x++)
// {
//   for(int y=0;y<21;y++)
//   {
//      for(int i=0;i<20;i++)
// {
//   for(int j=0;j<21;j++)
//   {
//     if(i!=x&&y!=j)
//     {
//       sum++;
//     }
//
//   }
// }
//
//   }
// }

//你的算法太天真了，不是x,y坐标都不同就一定 是新的直线了，随着x,y的增大，更多的点重合在一起，斜着的和更斜的多个重合也是有可能的，
//因此你这样根本解决不了问题，不是所有题目的规律都是这么好找的！
// printf("%d",sum+41);
//  return 0;
//}





//货物摆放
#include <stdio.h>
#include <stdlib.h>

//三个数，循环分割数字的思想，循环可以实现所有情况，取整分割数字，取模=0看看是否能整数分割，
//然后单个数字比较if判断即可
//核心就是分割加判断
#include<stdio.h>
int main()
{
    long long n=2021041820210418;//数字很大用
    long long l,w,h,s,k,sum=0;//sum赋值0!
    for(l=1;l*l*l<=n;l++)
    {
      if(n%l==0)
      {
        s=n/l;
        for(w=l;l*w*w<=n;w++)//w=l因为l给w已经探测过能不能整除了，所以就没有必要从头开始遍历
        //       l是前面分割的，w是现在准备分割的
        {
          // if(n%w==0),err，是切割后的数再切，不是原来的！
          if(s%w==0)
          {
            k=n/l/w;
            if(l==w&&l==k)
             sum++;
             else if((l==w&&l!=k)||(l==k&&l!=w))//严谨一点写两个条件
             sum+=3;
            else
             sum+=6;//这些代码都要建立在你有k的基础上！！！，要放进if条件去！
            
          }
          

          

        }
      }
    }
   printf("%lld",sum);
    return 0;
}
#include <stdio.h>
#include <stdlib.h>
int gcd(int a,int b)
{
  if(a%b==0)
  return b;
  else
  return gcd(b,a%b);
  //辗转相除得最大公约数
  //就是不断地拿a%b后面的数继续和后面的a%b比对
  
}
int gbs(int a,int b)
{
  return (a*b)/gcd(a,b);
  //最小公倍数=a*b/最大公约数
}

int min(int a,int b)
{
  return a<b?a:b;
}
int main(int argc, char *argv[])
{
  int i,j;
  int f[2022]={0};
  for(i=1;i<=2021;i++)
  {
    for(j=i+1;j<=i+21&&j<=2021;j++)//是j+1,自己不能连住自己的,1和1是没有路径的
    //思路就是从1开始一直到上限21
    //然后2到22
    //再3到23....一直探索赋值
    {
      if(f[j]==0)
      {
        f[j]=f[i]+gbs(i,j);
        //这是探索开拓赋值
      }
      else
      {
        f[j]=min(f[j],f[i]+gbs(i,j));
        //这里是比较最小的值.
      }
    }
  }
  
//循环的目的
//1.计算出总长度(毕竟不能快速直接得出1->21的长度)
//2.同时比较了最小路径
//注意i是固定的，一直动的是j,所以f[i]与f[j]不一定是前后关系，其实就是全面比对了
//i会和后面所有的数字比对路径长度，终点就是f[j]这个位置，
//f中其实一直都是到达该位置到达终点j的位置，因此每次都要加上f[i](前面路径的长度)
  printf("%d",f[2021]);
  return 0;
}
//收获：
//1.用循环(定一动一)来实现依次遍历从而重复用一个数组赋值，不同下标来实现路程合并和比较最小路径再赋值
//2.辗转相除和最小公倍数求法

//时间显示-
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  long long n;
  int HH,MM,SS;
  scanf("%lld",&n);
  //又不写&!屡教不改活该错,这次%都能漏了，粗心会让你一无所获,写代码你就继续犯病把
  n/=1000;
  HH=n/60/60%24;
  MM=n/60%60;
  SS=n%60;
  printf("%02d:%02d:%02d",HH,MM,SS);

  return 0;
}
//总结：思路正确，问题就是经常漏符号，一定要改正这个粗心的毛病，要有检查语法的习惯
//多使用调试测试，结果出问题就一定检查语法
//注意打印补齐，02d的作用是保持两位输出，当没有数字时用0补齐
//数字过大记得使用long long

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
//也是动态规划
//砝码重量
int main(int argc, char *argv[])
{
  int a[101][100001]={0};//最好初始化0
  //题设上限设空间
  int w[101];//用于存放单个砝码的重量
  a[0][0]=1;
  //相当于信标和必备条件，所有情况都必须建立在开始是两边为0的情况
  //将两边都链接起来
  int n,sum=0,ans=0,i;//sum，ans没有初始化！！!(细节扣分)
  scanf("%d",&n);
  for( i=1;i<=n;i++)
  {
    scanf("%d",&w[i]);
    sum+=w[i];//所有砝码重量的上限，用来检测循环上限。
  }
for(i=1;i<=n;i++)//砝码个数
//循环里面声明的i仅对循环里面有效
{
  for(int j=0;j<=sum;j++ )
  //sum作为上限，一一检索每一个重量的可能
  //以a[0][0]=1作为引导，不可能的重量一定赋值为0
  //这里j不能从1开始 必须从0 第一件物品不可能称出0 但是前i件可能称出0（两边重量相等时）
  //而且可能牵连到其他数值，反正多遍历一个也不吃亏
  {
    a[i][j]=a[i-1][j]+a[i-1][abs(j-w[i])]+a[i-1][j+w[i]];
    //     什么都不放       左边放            右边放
    //不用管这个加号，就是只要其中有一个那么目的就达成了，
    //我们的目的是为了探寻j下标点亮了多少个，
    //因为i是砝码，j是重量,目的就是为了看这个重量能不能成立。
    //      绝对值是因为负号只是代表方向，大小和正的是一样的
  }
}
//程序流程就是从1个砝码开始放，连接起0个砝码的情况(用信标)，类推

 for(i=1;i<=sum;i++)
 //为何不能i=0?
 //题设示例本可以什么都不放测出重量0，但是示例中没有，说明不包含0重量
 {
   if(a[n][i])
   //直接到n是因为我们本来就是要统计最终有多少个上限重量的个数
   //前面的计算都把1-n都叠加起来了
   //就以情况为例子，最多情况就可能有所有砝码总重量这么多，因为其他组合都算重复了
   //题目要求是不重复的情况，我们用总重量作为循环上限，规避了重复的情况，也实现了全面遍历.
   //(有就加1，没有就不加,反正最多就是总重量这么多情况
   {
     ans++;

   }
 }
 printf("%d",ans);
  return 0;
}
//经验
//不会用重量上限规避重复，设置情况上限,复杂问题很难直接解决的一定要用动态规划
//动态规划就是:设置起点标记1
//2.后面与前面用题目情景连接（用式子）
//3.循环一定要逐个检索

//#include <stdio.h>
//#include <stdlib.h>
//
//int main(int argc, char *argv[])
//{
//  int a[101];//记录每个砝码
//  int b[200][200];减去多个的数组
//  int n,sum;
//  scanf("%d",&n);
//  for(int i=1;i<=n;i++)
//  {
//    scanf("%d",a[i]);
//
//  }
//   for(int i=1;i<=n;i++)
//  {
//    scanf("%d",b[0][i]);
//
//  }
//for(int i=1;i<n;i++)//i不等于n!
//{
//  for(int j=i+1;j<=n;j++)
//  {
//
//  }
//}
//
//  return 0;
//}

#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
int main()
{
    long n, i, t = 100000000;
    ////x数据大你也放int 真服了
    //以后记住，如果不确定数据大不大，宁愿放long long也不放int
    //i会使得大的数据溢出错误，自己放int还是long一定要想好,包括循环里的变量
    int num = 1, flag = 0;
    long long int x;//数据大
    scanf("%ld", &n);
    if (n == 1)
    {
        printf("1");
        return 0;
    }
    for (i = 1; flag != 1; i++)
        //i就是当前数字的行位
        //注意i的大小，一开始是1，当这一次循环结束之后下一次就是二
        //所以当循环结束之前，使用的i其实是i-1,结束后才是真正的i。
    {
        
        num = 1;
        //数字在该行中的位置
        for (long j = 1; j <= i / 2 && j < t; j++)
            //j的作用就是将i分为两半，用于Cj,表格中就是Cj的规则,j最大不过i的一半
            //                             i            i
            
        {
            num++;//每次循环加1，相当于往右移一位
        //j与Num匹配，第二位就j=1,第三位就j=2
            x = 1;
            for (long k = 0; k < j; k++)
                x *= (i - k);
            for (long k = 0; k < j; k++)
                x /= (k + 1);
            //其实是排列组合的C几几.
            //这是表格中发现的规律详情看图
            //表格中每一个需要遍历的数（标黄的）,都符合C几几的规则
            
            if (x == n)
            {
                flag = 1;
                break;
            }
            if (x > n)//本可以不写，但是会超时
            {
                t = j;//数字只会因为循环越来越大
                //发现这一行的这个数超过我要的，我就跳出循环到下一行，
                // 因为后面只可能更大或者对称，根本不可能会有
                //而根据表格增长倍数，肯定不会超过当前的j，这是优化算法
                break;
            }
        }
        if (t == 2)//本可以不写，但是会超时,跟前面一样的，只不过减少了运行时间
        {
            num = 2;
            i = n + 1;
            break;
        }//不写超时，提前退出程序，最坏的情况,观察三角形可知，最坏的情况只可能是第二个数字出现.
        //如果j=2就超过了，这种就是第三位就超过了，那只可能在数位第二出现所以就是下一行.

        //优化算法很重要！特别是数据庞大的时候，其实x>n和t==2这两个本来都可以不用写，但是运行时间就会很长
        //超时就输出不了答案，因此就要学会技巧优化算法，主要还必须对模型理解的足够深刻才行
    }
    //最后循环结束完毕后就执行了i++,如执行时i一直等于4，结束循环以后回过循环时就会加上这个++
    //变为5，即i(该行数）

    //i换行，j，k,为c几几服务，num用于确定当前数字下标
    printf("%ld", num +   i*(i-1) / 2);
    //这个是上面的面积，实际上是梯形，因为上面1就相当于长度为1，而不是三角形，所以实际上就是梯形面积
    //((i-1)+1)*(i-1)/2,也可以理解为等差数列
    return 0;
}




 //二分法解
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>

long C(long a,long b,long n)
{
  long res=1;//一开始要赋值为1！
  for(long i=a,j=1;j<=b;i--,j++)
  {
    res=res*i/j;
  if(res>n)
  {
    return res;
  }//放循环里判断！优化算法
  //一旦这个res在循环中的结果已经有了超过n的就马上退出，不要再
  //等它全部遍历完返回再判断！
  }

  return res;

}

    
	int main(int argc, char *argv[])
	{
	  long n,k;
	  scanf("%ld",&n);
	  for(k=16;k>=0;k--)
	  //k代表需要遍历列数
	  //k--能写成k++，肌肉记忆是吧?
	  {
	    long l=2*k,r=n;
	    //l是需要遍历的行数,
	    //这里等于2k仅仅只是满足最大情况
	    //当最大情况不为所求时就用二分法
	    //矫正行数，这就是为什么二分法只分行数
	    //列不变，也是定一动一.
	    //int mid=(l+r)/2;
	    //这个要放里面，因为每次二分都是不同位置的！
	   
    while(l<=r)
 //二分法
       //l是左边界，r是右边界(r是要找的数字)
   //是寻找位置，我们很多信息不知道
          //但可以知道的就是，所寻找的数字永远
          //大于等于所在行，所以可以设边界
    {
       long mid=(l+r)/2;//划分中点
       //我们的二分法是为了寻找所求数字的
       //所在的行和列，而不是直接找到该数字！
       
      if(C(mid,k,n)==n)//mid是所寻找的行不是数字
      //中点恰好是要找的行
	        {
	          printf("%ld",(1+mid)*mid/2+k+1);
	          //这里是等差数列，每一行的全部是
	          //d=1的等差，1+2+3+......
	          //所以(a1+an)*n/2
	          //至于为什么加k+1,因为我们的排列组合规律都是
	          //因为下标从0才有的结论，所以其实是往下推了一行
	          //还要加上最后我们遍历到的位置(看图)
	          return 0;
      
      }
      else if(C(mid,k,n)>n)
      r=mid-1;
      //得数太大就只可能在左边一堆，
      //然后循环再分一次
      else
      l=mid+1;

    }
    //l>r就退出，因为l会一直往右，k会往左，
    //当l<=r时说明全部检索完毕没找到，就会进入下一个k
  }
  return 0;
}

//无法转换，放弃用c语言做(关键是无法做到数组与字符随意切换)
//循环字母有繁琐而且大概率超时，放弃,用c++解决
//c语言不像c++,要根据数据大小写int还是long!

//#include<stdio.h>
//#include<stdlib.h>
//#include<string.h>
////strcmp等函数使用
//int dir[] = {3,-3,1,-1};
//char set[10000];
//char str[10] = {'A','B','C','D','E','*'};//放外面避免递归干扰，主副函数都可以用
//void f(int x)
//{
//	//回忆，直接输入字符数组的名字就是整串字符比对 err
//	//c语言无法直接达到直接将所有字符串直接合并的操作
//
//	char a=str;
//	int i=-1;
//	do{
//		i++;
//		if(set[i]==str) 
//		return;
//		
//	
//		
//			
//	}while(set[i]!='\0');
//	//单双引加\0!
//	
//	strncmp(set[i],str,7);
//	
//	
//	
//    
//	for(int i=0;i<4;i++)
//	//循环加入的四种情况
//	{
//		int xx = x + dir[i];
//		if(xx>=0 && xx<=5){
//			char ch = str[x];
//			str[x] = str[xx];
//			str[xx] = ch;
//			f(xx);
//			ch = str[x];
//			str[x] = str[xx];
//			str[xx] = ch;
//		}
//		//递归的思想就是，我把所有qing'kuang
//	}
//}
//int main(){
//	int j=-1;
//	
//	f(5);
//	int n;
//	scanf("%d",&n);
//	for(int i=0;i<n;i++){
//		char st[10];
//		scanf("%s",&st);
//		do{
//				j++;
//				if(strcmp(set[i],st)==0) 
//					{printf("1");
//					return 0;
//					}
//			}while(set[j]!="0");
//	
//		printf("0");
//	}
//	return 0;
//} 

//c++
//移动字母
//本体解决方法也是二维变维，来简化字母移动
#include<bits/stdc++.h>//包含所有c++头文件
using namespace std;//相当于全局变量，所有地方变量都有效
void f(string str,int x);
set<string> s;
//将每次的string都储存在这个set中，名字为s
//存放数组
int dir[] = {3,-3,1,-1};
//这里是模拟二维的上下左右移动的情况，
//如果你只有1和负1那就不是字母移动的操作了，不符合题意
void f(string str , int x){
	if(s.count(str)) return;
	//检测s中有无该数组，有即重复就返回剪枝，
	//没有就插入到s中
	s.insert(str);
for(int i=0;i<4;i++)
//四次就是为了实现全部移动
  {
    int xx=x+dir[i];//移动下标
    if(xx>=0&&x<=5)
    {
      char ch=str[x];
      str[x]=str[xx];
      str[xx]=ch;//交换字母
      f(str,xx);
      //进入函数，判断是否重复，如果没有就继续沿着这条路探索新大陆
      //重复就返回剪枝
	  //你真的蠢，你放出去那都无条件递归了？
     ch=str[x];
      str[x]=str[xx];
      str[xx]=ch;//重复了就返回上一步的操作，
      //再同样换回来就行了然后循环继续看看还有无别的情况。
      //递归加所有的四次可能的移动==排列组合

    }
    // f(str,xx);//你真的蠢，你放出去那都无条件递归了？
    // char ch=str[x];
    //   str[x]=str[xx];
    //   str[xx]=ch;

  }
}
int main(){
	string str = "ABCDE*";
	//字符数组
	f(str,5);//上传
	int n;
	cin >> n;
	for(int i=0;i<n;i++){
		string st;
		cin >> st;
		//输入
		if(s.count(st))
		//判断s有无该字符串，
			cout << 1 << endl;
			//显示      换行
		else
			cout << 0 << endl; 
	}
	return 0;
} 

//123


//#define _CRT_SECURE_NO_WARNINGS
//#include <stdio.h>
//#include <stdlib.h>
////1,2,3错误示范
////复杂化写法
//int main(int argc, char* argv[])
//{
//    long long n, l, r;
//
//    scanf("%lld", &n);
//    //long x = l;//这个x要放到输入后才对！
//    long long sum1 = 0, sum2 = 0,s[100000], sum;
//    for (long long k = 0; k < n; k++)
//    {
//        scanf("%lld%lld", &l, &r);
//        long long x = l - 1;//这个x要放到输入后才对！
//        //你既然定义成了l-1,那你x也要跟着变！
//        for (long long i = 1; i <= l - 1; i++)
//        {
//         
//
//            if (x < i)
//            {
//
//                for (long long j = x; j >= 1; j--)
//
//                {
//                    sum1 += j;
//
//                   
//
//                }
//                break;
//            }
//            for (long long j = i; j >= 1; j--)
//            {
//               
//                sum1 += j;
//                //x -= i;//循环中i减了很多次，其实只用减一次的！
//                
//
//            }
//            x -= i;//循环中i减了很多次，其实只用减一次的！
//        }
//        x = r;//不同循环x不同
//        for (long long i = 1; i <= r; i++)
//        {
//            
//
//            if (x < i)
//            {
//                for (long long j = x; j >= 1; j--)
//                {
//                    
//
//                    sum2 += j;
//
//                }
//                break;
//            }
//            for (long long j = i; j >= 1; j--)
//            {
//                
//                sum2 += j;
//               /* x -= i;*/
//                
//                //内循环没有初始化！
//            }
//            x -= i;//循环中i减了很多次，其实只用减一次的！
//        }
//        s[k] = sum2 - sum1;
//       
//
//
//    }
//    for (long long k = 0; k < n; k++)
//    {
//       printf("%lld\n", s[k]);
//    }
//   
//
//
//    return 0;
//}
////小范围适用大范围不行，溢出了徒劳无功，方法太复杂太暴力，以后思路不能这么直白和复杂，
////如果这么写程序不如一早就把这个方法抛弃，不然到时候修bug根本不好修，还不断错根本改不好，而且效率也不高，
////超时了，记住，一堆循环的百分百拿不了多少分



//二分法
#include <stdio.h>
#include <stdlib.h>
#define max 1414214//不用加;
//题设是第l个数到r个数的和
//最大上限是10的12次方个数字
//跟据观察发现每组都是等差数列
//计算可知最多为1414214组

long long a[max];
long long s[max];
//二分查找
//用该方法查找出i前一个或者其中的数列下标(a[mid])，然后带入公式
//注意，这里是对a数组的下标查找
//这个mid是查找数组的下标
long long sum(long long i)
//i是当前位置下标
{
  long long l=0,r=max;//两个数组边界下标
  //开始l为0是因为这是数组下标的边界
  while(l<r)
  {
    long long mid=((l+1)+r)/2;
    //!!注意前面是加法，要括号括起来！
    //循环加1首先是因为0下标没有数据可以直接跳过
    //其次是为了下一次的l加上1,实现二分查找。
    //如果此时已经完成查找，那l就不需要为了循环加1
    //这么写是因为要传出l

    if(a[mid]>i)
    r=mid-1;
    else
    l=mid;
    //这里是因为循环时mid加了1所以mid不用加一
			//不能直接改l=1,这里牵扯到一直循环，
			//如果先改一，然后l变为mid加一，那就牵连在一起循环
			//下标就是不一样的了，为了直接返回正确的下标，优先
			//考虑将正确的mid固定住
			//不直接用Mid是为了缩小范围，减小遍历的算法,不然就超时
  }
  //二分法仅仅是工具，用来优化算法,比循环提高了2的n次方效率,
      //用2分法把位置定为中点，两边都可以找，提高遍历速度,
      //就是一直压缩位置的范围，然后就可以快速输出(因为数据不大)
      //用二分查找代替循环遍历，
      // 记住，插入可以循环，但遍历一定要找其他方法代替！

     
  return s[l]+a[i-a[l]];
  //这个是递推式，由数列规律可以知道
  //返回不用r只用l,公式研究左边的写法
  //
 //因为题目要的不是位置,人家要的是一连串的总和，所以不能直接返回中点值！
//我们根本不需要考虑mid是否又被取到，a[mid]<=i都是符合这个公式的
  //只要l<r就是成立的,

}

int main(int argc, char *argv[])
{
 for(int i=1;i<=max;i++)
 {
    a[i]=a[i-1]+i;
    s[i]=s[i-1]+a[i];
 }
 int n;
 long long l,r;
 scanf("%d",&n);
 while(n--)
 {
    scanf("%lld%lld",&l,&r);
    printf("%lld\n",sum(r)-sum(l-1));
    //关于函数的，就看你函数返回的值是什么类型的
    //这里l-1是因为l的数字也要包括在内，所以往前挪

 }
  return 0;
}

//数字三角形
#include <stdio.h>
#include <stdlib.h>
#include<math.h>
int max(int a,int b)
{
  return a>b?a:b;
}

int main(int argc, char *argv[])
{
 int n,s;
 int a[101]={0};
 //初始化啊别忘了！不初始化一堆乱码跟他们比大小比不死你
 scanf("%d",&n);
 for(int i=1;i<=n;i++)
 {
   for(int j=i;j>=1;j--)
   //全部倒着输入，就相当于把三角形翻转过来，结果是不会变得
   //倒着输出是为了防止冲突
   //(因为我们一行代码包含了选择连上一行的最大数字的表述
   //还有插入输入的数字）
   //倒着输出，每次都是开新的数组，可带入数字验证不会起冲突.
   //还有就是看题目的图和表述，不能跨越过大，只能选最近的两边
   //这就是为什么只有a[j]与a[j-1]的比对
   {
     scanf("%d",&s);
     a[j]=max(a[j],a[j-1])+s;
   }
   
 }
 if(n%2==0)
 //偶数情况
 //根据题目，因为左下走的次数和右下次数相差为1，
 //只可能在最中间一个数，
 //而中间就要讨论最后一行是奇数还是偶数！
 {
   printf("%d",max(a[n/2],a[n/2+1]));
 }
 else
 //奇数情况
 printf("%d",a[(1+n)/2]);

  return 0;
}

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  int x[21]={0};
  int n,sum=0,m,ans=0;
  //圆的总周长,每一段弧长，统计矩形的个数
  scanf("%d",&n);
  for(int i=1;i<=n;i++)
  {
    scanf("%d",&m);

    x[i]=x[i-1]+m;//为了得到每一段的前缀和使用的数组
    //为的其实就是后面的循环
    sum+=m;

  }
  for(int a=1;a<=n-3;a++)
  for(int b=a+1;b<=n-2;b++)
  for(int c=b+1;c<=n-1;c++)
  for(int d=c+1;d<=n;d++)
  //初始时每一个点各占据一个不重复位置的点，防止重复统计一个矩形
  //四个点是因为矩形由四个点组成
  //至于上限就是最后尽头时每个点都有不与自己的点的重复的位置
  //然后循环就是排列组合
  //算法是平行的边长相等，边长相等就等价于弧长相等
  
  {
    if(x[b]-x[a]==x[d]-x[c]&&sum-(x[d]-x[a])==x[c]-x[b])
    //为了不重复和统计不同情况的矩形，我们就需要移动点的位置
    //一旦移动那就不是原来点的弧长，这就是为什么不导入对应点的
    //弧长而是前缀，虽然点的位置再变，但他们两个之差是不会变的
    //只要差是相等的，那就一定可以组成一个矩形，
    //而单单一段弧长，下标变了就难以锁定，所以用差来锁定边长
    //包括为什么(x[d]-x[a])不能用x[a]代替，sum为什么不能用x[d]
    //因为下标在移动,但是形成矩形的情况一定是和第一次一样的，只不过位置不同
    
    ans++;
  }
  printf("%d",ans);
  return 0;
}

//谈判
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  int a[1001];
  int b[1001]={0};
  int n,m;
  long long sum=0;
  scanf("%d",&n);
  for(int i=1;i<=n;i++)
  {
    scanf("%d",&m);
    a[i]=m;
  }//插入数组
  
  for(int i=1;i<=n;i++)//排序，按顺序把小的排在前面
   for(int j=i+1;j<=n;j++)
   {
     if(a[i]>a[j])
     {
       int tmp=a[i];
       a[i]=a[j];
       a[j]=tmp;
     }
   }
for(int i=1;i<=n;i++)
{
  b[i]=b[i-1]+a[i];//记住b要初始化！
  //迭代
  if(i>=2)//因为一开始要两个部落。
  sum+=b[i];
}
printf("%lld",sum);


   
  return 0;
}

//含两天数
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
   long count=0;
 for(int i=1900;i<=9999;i++)
 {
   int flag=i;
   while(flag)
   {
     if(flag%10==2)
     {
      //  if(flag%4==0&&flag%100!=0||flag%400==0) err
      //依然要拿i来判断，你flag会变，这个判断闰年经过循环就失真了！
      //避免这种思考就建立函数，函数传参写好直接判断打包好就避免出错
      
      if(i%4==0&&i%100!=0||i%400==0)//闰年判断方法记好了！
       {
         count+=366;
        
         break;//一旦出现了2就要跳出去
         //不不不，你这个只是跳出了while
         //并没有跳出for，所以要设置条件
       }
       else
       {
         count+=365;
        
         break;
       }
      
     } 
     flag/=10;
   }
   if(flag)//因为如果flag为真，那么肯定是年中有2，所以直接进入下一次循环就好了
   {
     continue;
   }
   
   
   else//flag为假，说明上个while循环直到最后都没有，说明年中无2.
   {
     if(i%4==0&&i%100!=0||i%400==0)
       {
         count+=180;//179加上闰年的日期2/29
       }
       else
       {
         count+=179;//没有2的普通一年总共有2的月/日
       }
     }
 }
    
 printf("%ld",count);
  return 0;
}
//分数

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  int a=pow(2,20)-1;
  int b=pow(2,19);
  printf("%d/%d",a,b);
  return 0;
}
//不用约分，你多虑了，就是你那种暴力数学解题
//唯一要改进的就是使用这个数学公式，不用手算，直接pow次幂直接计算
//分数就用打印符号的 /来表示分数，题目没说就不用约分！


//饮料换购
#include <stdio.h>
#include <stdlib.h>

int drink(int n)
{
  int flag =n,count=0;
  while(flag>=3)
  //不用担心n<3,直接返回n也是一样的.
  {
    int a=flag/3;
    int b=flag%3;
    count+=a;
    flag=a+b;

  }
  return(n+count);
}

int main(int argc, char *argv[])
{
  int n;
  scanf("%d",&n);
  printf("%d",drink(n));
  return 0;
}


#include <stdio.h>
#include <stdlib.h>

//错误票据
//你的劣质算法
int main(int argc, char *argv[])
{
     输入
     //循环输入的次数
     然后后面再来个10000如果出现“ ”字符就跳出这个循环
     不会缺号，但用冒泡排序查重
  return 0;
}

//优化
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
    int max=-1;//输入的肯定是正整数
    int min=100010;//最大上限为10的5次方
    //这两个是确定遍历范围
    //这么赋值是保证第一次max与min都能被附上第一个数，然后跟后面的数字比大小
    int b[10010]={0};//最多100*100个数，多几个防溢出
    //作用是统计数字出现次数
    int line,a,m,n;
    scanf("%d",&line);//题目要求输入几行，但是解答根本用不上，所以不用管
   
    
      while(scanf("%d",&a)>=0)
      //用这个条件代替你愚蠢的" "识别，
      //事实上是所有非法字符而非仅有" "!
      //这里一定要>=0,首先就是输出一定要有效
      //不能直接写scanf("%d",&a),范围太大会超时
      {
        if(a>max)
        {
        max=a;
        }
        if(a<min)
        {
          min=a;
        }
        
        b[a]++;
        //哪个数字出现就在哪个下标加一
      
    }
    for(int i=min;i<=max;i++)
    {
      if(b[i]==0)//判断缺号
      m=i;
      if(b[i]>1)//重号
      n=i;
    }
    printf("%d %d",m,n);

    
  return 0;
}

//数组下标加遍历范围计数统计代替你的冒泡排序还有你不会处理的缺号


//扫地机器人
////#include <stdio.h>
//// #include <stdlib.h>
//
//// int main(int argc, char *argv[])
//// {
////   int n,k,sum=0;
////   scanf("%d%d",&n,&k);
//
////   sum+=(n/k);
////   sum+=(n%k);
////   printf("%d",(2*sum)-2);
//
//
////   return 0;
//// }//你这是最优解讨论，如果人家不按照最优解给你放顺序那就没有意义了


#include <stdlib.h>

// int main(int argc, char *argv[])
// {
//   int n,k,sum=0,s=0,u=0;
//   int dp[100001]={0};
//   int s[100001]={0};
//   scanf("%d%d",&n,&k);
// for(int i=1;i<=k;i++)
// {
//   scanf("%d",&a);
// dp[i]=a;
// }
// //插入是随机的，位置不按顺序还要再冒泡排序
// //

// if(dp[k]<=(1+n)/2)
// {
//   printf("%d",((n-k)-1)/2);
// }
// else
// {
//   for(int i=2;i<=k-1;i++)
//   {


//     if(i==2)
//     {
//       s= max(dp[i]-1,s);
      
//       continue;
//     }
//     s=max(dp[i]-dp[i-1],a);
   
//     if(i==k-1)
//     {
//       a[i]=max(n-dp[i],s);
//     }
//   }
//   //   for(int i=2;i<=k-1;i++)
//   // {
//   //    u=max(dp[i]-dp[i-1],u);
     

//   //   if(i==2)
//   //   {
//   //     u= max(dp[2]-1,u);
      
//   //     continue;
//   //   }
   
//   //   //不会选倒数第二个小的
//   //   if(i==k-1)
//   //   {
//   //     u=max(n-dp[i],u);
//   //   }

//   //   if(u!=s)
//   //   {

//   //   }
//   // }
  
//   //最高的一个数总会卡位置，无法使用最大最小值输出倒数第二大的数，只能冒泡排序了

//   //将数据全部塞进数组，然后冒泡排序，输出倒数第二个数据即可
//   //算法就是分两种情况。一是所有输入数据中没有超过中间的，那就只能输出离最后一个位置最近的数
//   //研究规律得出是((n1-n2)-1)/2
//   //第二种就是上面的不满足就要比对两数之间的距离，其中头和尾要在前一个数据衡量，因为如果他们
//   //不是最大的就只有一个机器承担这些，输出倒数第二是因为第一会有机器帮它。算法过于复杂舍弃了.
  

// }


// 核心在于对问题的转化，每台机器虽然可以不同打扫范围
// 但是只有满足在所有机器用同样的打扫范围时能够完全打扫完
// 长廊，才可能实现目标
// 因此只需要求出满足条件的最小的打扫范围就好了


#include <stdio.h>
#include <stdlib.h>

int robot[100001];//机器人位置

int i, n, k;
//把这些写在全局变量就省去、解决了很多传参的麻烦
int cmp(const void *a,const void*b)
{
  return *(int*)a-*(int*)b;
}

int check(int len)//清扫范围
{
  int sweep=0;//当前打扫的位置
  for(i=0;i<k;i++)
  {
    if(robot[i]-len<=sweep)
    //减代表向左遍历看范围是否可以打扫完全
    //不完全就退出，因为非法，必须要全部打扫
    {
      if(robot[i]<=sweep)
      //判断当前机器人是否在已经打扫过的范围
      //即机器人之间的打扫范围是否有重合
      {
        sweep=robot[i]+(len-1);
        
       ///如果当前机器人已经处于清扫过的位置，则当前机器人只扫右侧区域
        //自己的脚下也属于一片范围，所以要减1,
        //至于sweep为什么要赋值上，因为这是每个机器人一样的打扫范围
        //打扫区域的重合是不可避免的，只能沿着每个机器人的打扫范围的极限来推进
        //sweep的位置是建立在机器人打扫的范围中的！
      }
      else
      //因为当前机器人在sweep前面，机器人的脚下也是sweep没有走过的
      //因此直接加上这个机器人的打扫范围表示这个区域都能打扫到了
      sweep+=len;
    }
    else
    return 0;
  }
  //return 1; err
  return (sweep>=n);
  //为什么？
  // return 1仅仅只是起到返回真值的作用，即使前面都保证正确
  //也无法保证机器人数量或者放置的位置不好就不能完全覆盖后面的区域
  //所以即使前面的区域能覆盖，还要最后保证sweep>=n才能
  //全覆盖，这是还有一小部分的情况，所以你会拿不完分
  //这里意思就是判断，如果sweep>=n,你就返回真值，否则返回假值
  
}
int main(int argc, char *argv[])
{
scanf("%d%d",&n,&k);

for( i=0;i<k;i++)
{
  scanf("%d",&robot[i]);

}
qsort(robot,k,sizeof(int),cmp);
//输入是随机的，所以要排好序先
//选定数组开始位置,排序数量，每个字符大小，方向
//排序函数，学习，以后可以代替冒泡排序
//cmp决定排序方向，a-b升序，b-a降序


//不写取地址，就默认是直接传数组的首位地址
//相当于robot[0],不写&就是首位，所以从零开始的
//循环可以直接写数组不写&，
//如果要从1开始就要：
// for(i=1;i<=k;i++){
//         scanf("%d", &A[i]);
//     }
        
//     int left=0,right=n;
//   qsort(&robot[1],k,sizeof(int),cmp);

int l=0,r=n,t;
//二分查找，寻找出当前放置位置中每个机器最短时间的打扫范围
while(l<=r)
{
  int mid=(l+r)/2;
  if(check(mid))//条件为真就执行
  {
    r=mid-1;
    t=mid;
    //这个是记录当前最短时间的范围
    //因为这时的值已经成功了，一直到最后
    //最后标记的t就是最好的范围

  }
  else
  {
    l=mid+1;
  }
}

printf("%d",(t-1)*2);
//题目知，一台机器四个大小的范围时
//消耗时间为6，规律


    
    
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
 
int main(int argc, char *argv[])
{
 char * tiangan[10] = {"jia","yi","bing","ding","wu","ji","geng","xin","ren","gui"};
 char * dizhi[12] = {"zi","chou","yin","mou","chen","si","wu","wei","shen","you","xu","hai" };
 //要么指针数组要么二维数组，因为一个数组空间只能放一个字母，长串字符要么就用指针代替，要么就用二维
 //一个一个字符放，用行代表一个字符串
//  char b[10][10]={"jia","yi","bing","ding","wu","ji","geng","xin","ren","gui"};
// char a[12][10]={"zi","chou","yin","mao","chen","si","wu","wei","shen","you","xu","hai"};
  int n,j,k;
  scanf("%d",&n);
  int c=n%60;
  //计算n的余数来压缩遍历范围，再通过循环移动下标，
  //得到正确的下标后输出
  if(c==40)
  //庚子年时余数是40
  {
    printf("%s%s",tiangan[6],dizhi[0]);
  }
else if(c<40)
{
    j=6;
    k=0;;//初始化，只移动下标就行了
    //标记庚子年的下标然后开始移动
    for(int i=0;i<40-c;i++)
  {
    
  if(j==0)
  j=10;
  if(k==0)
  k=12;
   j--;
    k--;
   
  }
 
}
else
{
   j=6;
    k=0;//初始化，只移动下标就行了
    for(int i=0;i<c-40;i++)
  {
    if(j==9)
  j=-1;
  if(k==11)
  k=-1;
   j++;
    k++;
  }
  
  //对于这种你不清楚该怎么赋值，哪个代码该写在前面
  //你就自己假设带入要跳转的时刻的数据，自己按照程序的单个循环
  // 写出一个能实现自己想要的效果的代码就可以了
  //如j==9,k==11,我想在这个循环里实现跳转到0,0,我应该怎么做
  //就这么模拟实景就行了
  
}
printf("%s%s",tiangan[j],dizhi[k]);
//递减还是递增如何实现到尽头时自动跳转太麻烦，用循环算法太复杂
//笑死，你还是把它写出来了
  return 0;
}

//前面一直卡住我们的是下标转移不好移
//通过求余数发现公元40年是庚子年
//所以我们可以自行往前推，求出公元0年时
//是什么年，然后把公元一年作为第一，
//第0年就和数组下标同步了
//数据导入到数组，然后我们就可以通过
//求余直接得出答案
 
// 即:利用下标和年同步，用求余实现自动转一下标！
 
#include <stdio.h>
#include <stdlib.h>
 
int main(int argc, char *argv[])
{
 char * tiangan[10] = {"geng", "xin", "ren", "gui", "jia", "yi" , "bing", "ding", "wu", "ji"};
 char * dizhi[12] = {"shen", "you", "xu", "hai", "zi", "chou", "yin", "mou", "chen", "si", "wu", "wei"};
 int n;
 scanf("%d",&n);
 
printf("%s%s",tiangan[n%10],dizhi[n%12]);
 
  return 0;
}


//小数第n位


// 本质上是因为幂随n的增大导致长整型的溢出，因此我们必须缩小数据大小
// 同时也是为了提高算法效率同样也需要用快速幂解题
// 我们的qpow函数并没有达到做到直接计算出a^n这个答案，我们仅仅只是为题设服务
//就是输出指定位置的3个数据，将庞大的数据压缩,一边检索一边舍去不要的答案来实现成功输出

#include <stdio.h>
long long a,b,n;

long long qpow(long long x,long long y){
  long long res=1;

  while(y)
{
    if(y&1)
    {
      res=res*x%(b*1000);
    }
    y>>=1;
    x=x*x%(b*1000);
  }
  return res;
}   
 //在快速幂的基础上，取模b*1000;
  //在主函数中说过都是从1开始计算的
  //这里的1000也是为了直接输出整数答案
  //我们先不用1000
// if(y&1){
//       res=res*x%(b);
//     }
//     y>>=1;
//     x=x*x%(b);
//   {

  //假设现在是10/7
  //计算得知为1.42857...
  //然后10%7=3
  //3/7=0.42857....
  //可以发现前面的数字一被这个操作去除了
  //假设n=3，b=7,a=1
  //那么程序开始时,因为是10^(n+2)
  //所以n=1时，ans=1000<b*1000
  //假设直接带回输出，然后/7
  //答案为142，从第一位开始，很合理
  //而从第二位,ans=10000>b*1000
  //取模可得ans=3000
  //a/b=0.142857...
  //3000/7=428，第二位，合理
  //然后n=3时,快速幂算法得知
  //10<b*1000
  //10*10^4=100000>b*1000
  //取模得到2000
  //2000/7=285得到第三位
  
  //实际上是因为取整就是拿了小数点之前的数
  //取模就是之后的数，将之后的数*1000就是答案
  //而随着你的幂不断增大
  //如1变为100
  //1/7=0.142857...
  //100/7=14.2857...
  //数字变大自然而然地会增加整数，减少小数
  //因此取模之后小数部分也就自然向后走了
  //包括10^4*10^8=10^12也是一样
  //保留了res继续取模也是接着取模去除的
int main(){

  scanf("%lld%lld%lld",&a,&b,&n);
  long long ans=(a*qpow(10,n+2)%(b*1000))/b;

  //实际数字a只是倍数，都是在a=1的运算基础上乘上一个倍数，
  // 所以再乘a就可以得出想要的结果
  //这里还取一次模是因为a会改变qpow中的ans的大小
  //同理要重新确定范围，然后取出小数范围，
  //最后/b输出小数部分！


  printf("%lld\n",ans);
  return 0;
}
//   总结:取模相当于分割整数和小数，
//   可以连续取模，不影响最终结果

// 10^(n+2)还有1000都是为了小数点后三位直接输出服务的
//如1000，用不到取模就要10^3/8=125输出结果
//如果用上了取模就要保留千位来输出三位整数
//千位或者以上，全看b的大小，但因为b为除数，
//怎么输出都是3位数字的结果

//题目本质是余数/除数得出小数后位的结果!
//幂的增和a会影响整数范围,决定划分点,b起到分划的作用
//(//1/7=0.142857...
  //100/7=14.2857...)
//a%b相当于划定整数和小数范围
//a/b是取到整数的范围
//而a%b是取到了小数的范围，
//但本身是余数，需要再次/b才能转化成小数部分


//人物相关性分析
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int a[1000010]={0};
int b[1000010]={0};
  char str[1000010]={0};
  //不要自认为不可能，上限多高就要设多大，不然超过数组大小就会溢出运行就会错误
  //你把ab设成10^5，就有两个数据通不过！！
  //记住，运行错误不是超时，最可能就是溢出，如类型和数组大小，这些不确定的你就
  // 根据上限设大，或者long long，宁可设大也不设小.设到上限还要多几个也是防溢出.

  int check(char x)
  {
    return (x>='a'&&x<='z'||x>='A'&&x<='Z');
    // 自动判断，满足条件返回真值，否则假值
    // if语句&&必须所有都是真，一个假自动不进入if中
  }
  //判断是否为独立单词，左右两边没有多余的字母
  //只要你是这其中的字母，我就不要
  //但是其他字符就可以
  

int main(int argc, char *argv[])
{

int k,flag=0;
  long long ans=0;
  scanf("%d",&k);
   getchar();//吸收scanf的缓冲
  gets(str);
  //输入一行字符串
  long long len=strlen(str);
  //统计字符串长度

  for(long long i=0;i+5<=len;i++)
  {
    if(str[i]=='A'&&str[i+1]=='l'&&str[i+2]=='i'&&str[i+3]=='c'&&str[i+4]=='e')
    if(!i&&!check(str[i+5])||!check(str[i-1])&&!check(str[i+5])||!check(str[i-1])&&i+5==len)
       a[flag++]=i;
       //记录首字母出现的位置

        //i==0时无需判断左边是否有字符
                //i+5没毛病，一开始从0下标开始,加5就到了e的右边
                //i为第一个字符下标，i-1前一个
                //三个条件分别为左中右
  }
  // long long la=sizeof(a)/sizeof(a[0]);
  //这个算的总数是数组的整体大小，即使你没有赋值，
  //你总共开创的数组有多大总体就有多大，所以不能这么写
 long la =flag;
 //记录数组长度,为了记录出现了多少个Alice
  

  flag=0;//重置flag 

    for(long long i=0;i+3<=len;i++)
  {
    if(str[i]=='B'&&str[i+1]=='o'&&str[i+2]=='b')
    if(!i&&!check(str[i+3])||!check(str[i-1])&&!check(str[i+3])||!check(str[i-1])&&i+3==len)
       b[flag++]=i;
  }
long lb =flag;//记录
  

  for(long long i=0,l=0,r=0;i<la;i++)
  //先固定Alice,然后判断与Bob位置

  {//注意是查找到哪个字母算不超过，据题意只要碰到了一个单词都算不超过
  //你的想法是对的，旁边连续的BOb如Alice and Bob.Bob也是两次
    while(l<lb&&b[l]+2<a[i]-k)//A左边的Bob
    //因为记录的是他们的首字母，我们需要根据首尾单词的位置判断
    
    l++;
    while(r<lb&&a[i]+4+k>=b[r])//右边的
    r++;
    ans+=r-l;

    // 整个维护过程就是l减r增,如果l不增，说明Bob都在范围内,因此每一次的Alice都能加上这个Bob
    // 所以r不用重置和初始化，每一次循环都加上一次，一旦l增说明超出范围，此时A不能再加，
    // 因此减去.而每次循环的Alice都是越来越后的，所以l也不用重置,每一次都要减去这一次的l
    //同时也要保留加上这个r(因为存在循环时l和r都不变的情况)
    // 同时l和r一直记录着减去和增加的数量，每一次的Alice都是直接加在ans上的，因此这个操作只是针对
    // 每一次，对于每一次而言，我们只需要把满足条件的Bob新加进来，不满足的减去
    // 也就是r-l了。前面累积的结果就是通过l与r的记录表示.

    // 如果总是从头遍历，每次从第一个Bob开始就会超时，这么写的好处在于检索的Bob和Alice一直都是
    // 向前推进的，没有回头，避免重复的检索.

   //简言之就是每一个Alice，满足的就加进来，不满足就舍去，左边舍去，右边加
   //同时l与r还充当遍历下标，只要l与r增加我就可以再向后遍历一个Bob看看满不满足
   //因为旁边连续的BOb如Alice and Bob.Bob也是两次


  }
  printf("%lld",ans);
  
  return 0;
}

// 总结:l与r分开记录就是为了单独识别左边和右边的判断推进，如果r增，说明有A能够在范围内，他们就算同时出现一次
// 所以r可以推进到下一个Bob，也就是以后我都不需要再遍历这个Bob了，这就避免了重复遍历
// 同理l推进也是，当出现Bob脱离当前A的范围，
//也可以推进了，因为当前的A都已经脱离，那么后面的也一定脱离，就避免了对前面Bob的重复遍历


//赢球票



#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    int a[101];
    int flag[101];
    int ans, n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);//最好还是对应下标来写，用if代替取模
    }
    for (int i = 1; i <= n; i++)
    {
        int pos = i, num = 0, count = 0, sum = 0;
        //现在移动到的位置，还是现在数的数字，这两个要分开写才清晰！
        for (int k = 1; k <= n; k++)
        {
            flag[k] = 0;
        }//重置标记过的卡片
        while (1)
        {//数的数字超过了和数完了所有卡牌就退出.
            if (num > n || count == n)
                break;

            if (flag[pos] == 1)
        //重复卡片(位置)直接移动到下一个位置，但是数的数是没有变化的，代表这个卡片被拿走了
            {
                if (pos == n)
                    pos = 1;
                else
                    pos++;
                continue;
            }

            if (num == a[pos])
            {
                sum += num;
                num = 1;//重置数的数
                count++;
                flag[pos] = 1;//标记该位置表示拿走了
                if (pos == n)
                    pos = 1;
                else
                    pos++;

            }
            
            else
            {
                num++;
                if (pos == n)
                    pos = 1;
                else
                    pos++;
            }
            //最重要的一步你都没写！
            //数的数字和当前位置数字不相等你也要考虑
            // 如果考虑不周，你就带入数据自己模拟环境
            // 想想有什么可能性，下一步应该做什么，你就很清楚了


        }
        if (ans < sum)//最大值
            ans = sum;
    }

    printf("%d", ans);
    return 0;
}

//既约分数

#include <stdio.h>
#include <stdlib.h>
int s(int a,int b)
{
  // if(a%b==1)//记错了，整除到0为截至，b的一方为最大公因数！
  // {
  //   return 1;
  // }
  // else
  // return s(b,a%b);
  // return 0;

   if(a%b==0)//记错了，整除到0为截至，b的一方为最大公因数！
  {
    return b;
  }
  else
  return s(b,a%b);

  return 0;
}
int main(int argc, char *argv[])
{
  long long count=0;
  for(int i=1;i<=2020;i++)
  for(int j=1;j<=2020;j++)
  {
    if(s(i,j)==1)
    {
      count++;
    }

  }
  printf("%lld",count);
  return 0;
}

//蛇形统计
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  int ans=1;
 for(int i=2;i<=20;i++)
 {
   ans=ans+(i-1)*4;
 }
 printf("%d",ans);
  return 0;
}//上一个数+其下标*4


#include <stdio.h>
#include <stdlib.h>

//没看到日期，以为是单纯的数字叠加！
int main(int argc, char *argv[])
{
  long long n,i,huiwen1=0,huiwen2=0;
  scanf("%lld",&n);
 for(i=n+1;i<=99999999;i++)
  {
    if(i/10000000==i%10)
    {
      if(i/1000000==(i%100/10))
      {
        if(i/100000==(i%1000/100))
        {
          if(i/10000==(i%10000/1000))
          {
            printf("%lld\n",i);
          }
        }
      }
    }
  }

 for(i=n+1;i<=99999999;i++)
  {
    if(i/10000000==i%10)
    {
      if(i/1000000==(i%100/10))
      {
        if(i/100000==(i%1000/100))
        {
          if(i/10000==(i%10000/1000))
          { 
            if((i%10)!=(i%100/10)&&(i%10)==(i%1000/100))
            printf("%lld\n",i);
          }
        }
      }
    }
  }


  return 0;
}


#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char* argv[])
{
    int n, i, year, j, k;//类型大了不影响结果
    int huiwen1 = 0, huiwen2 = 0;
    scanf("%d\n", &n);
    year = n / 10000;

    //先进月份，才能判断日期，相等即可，日期就循环判断
    //谁先找到谁先break，然后再开个循环继承那一年
    //为了保证下一个回文先输出我先设条件
    //不行，只有开两个循环单独找才行，你不确定他们两个到底谁先出现
    for (i = year; i <= 8999; i++)
    {
        for (j = 1; j <= 12; j++)
        {
            if ((i % 100 / 10) == (j % 10) && (i % 10) == (j / 10))//截取月份的数字相同
            {
                if (j == 2)
                {
                    if ((i % 4 == 0) && (i % 100 != 0) || i % 400 == 0)//闰年
                    {
                        for (k = 1; k <= 29; k++)
                        {
                            if (i / 1000 == k % 10 && i / 100 % 10 == k / 10)
                            {
                                if (huiwen1 != 1)
                                {
                                    printf("%d%d%d%d%d\n", i, j / 10, j % 10, k / 10, k % 10);
                                    huiwen1 = 1;
                                }

                                if ((k % 10) == (j % 10) && (k / 10) == (j / 10) && (k % 10) != (k / 10) && huiwen2 != 1)
                                    //因为对称性，我们只需要判断一半就可以了,ABABBABA
                                {
                                    printf("%d%d%d%d%d\n", i, j / 10, j % 10, k / 10, k % 10);
                                    huiwen2 = 1;
                                }

                            }
                        }



                    }
                    else
                    {
                        for (k = 1; k <= 28; k++)
                        {
                            if (i / 1000 == k % 10 && i / 100 % 10 == k / 10)
                            {
                                if (huiwen1 != 1)
                                {
                                    printf("%d%d%d%d%d\n", i, j / 10, j % 10, k / 10, k % 10);
                                    huiwen1 = 1;
                                }

                                if ((k % 10) == (j % 10) && (k / 10) == (j / 10) && (k % 10) != (k / 10) && huiwen2 != 1)
                                    //因为对称性，我们只需要判断一半就可以了,ABABBABA
                                {
                                    printf("%d%d%d%d%d\n", i, j / 10, j % 10, k / 10, k % 10);
                                    huiwen2 = 1;
                                }
                            }
                        }
                    }
                }

                else if (j == 4 || j == 6 || j == 9 || j == 11)
                {
                    for (k = 1; k <= 30; k++)
                    {
                        if (i / 1000 == k % 10 && i / 100 % 10 == k / 10)
                        {
                            if (huiwen1 != 1)
                            {
                                printf("%d%d%d%d%d\n", i, j / 10, j % 10, k / 10, k % 10);
                                huiwen1 = 1;
                            }

                            if ((k % 10) == (j % 10) && (k / 10) == (j / 10) && (k % 10) != (k / 10) && huiwen2 != 1)
                                //因为对称性，我们只需要判断一半就可以了,ABABBABA
                            {
                                printf("%d%d%d%d%d\n", i, j / 10, j % 10, k / 10, k % 10);
                                huiwen2 = 1;
                            }
                        }

                    }

                }
                else
                {
                    for (k = 1; k <= 31; k++)
                    {
                        if (i / 1000 == k % 10 && i / 100 % 10 == k / 10)
                        {
                            if (huiwen1 != 1)
                            {
                                printf("%d%d%d%d%d\n", i, j / 10, j % 10, k / 10, k % 10);
                                huiwen1 = 1;
                            }

                            if ((k % 10) == (j % 10) && (k / 10) == (j / 10) && (k % 10) != (k / 10) && huiwen2 != 1)
                                //因为对称性，我们只需要判断一半就可以了,ABABBABA
                            {
                                printf("%d%d%d%d%d\n", i, j / 10, j % 10, k / 10, k % 10);
                                huiwen2 = 1;
                            }
                        }
                    }
                }







            }



        }
        if (huiwen1 == 1 && huiwen2 == 1)
        {
            return 0;


        }


    }

    return 0;

}


#include <iostream>
using namespace std;

bool isLeap(int y)//判断闰年
// 长的代码或者重复使用的最好写在一个函数里防止出错
{
    return (y%4==0&&y%100!=0)||(y%400==0);
}

//让测试数据自己判断是否正确
bool check(int year,int month,int day){//判断是否为合法日期
    if(month>12||month==0) return false;
    if(day>31||day==0) return false;
    if(month==2){
        if(isLeap(year)&&day>29)
            return false;
        if(!isLeap(year)&&day>28)
            return false;
    }
    if(month==4||month==6||month==9||month==11){
        if(day>30) return false;
    }
    return true;
}
int main()
{
    int n,i;
    cin>>n;
    int a,b,c,d,e,f,g,h;//8位数字
    int year,month,day;
    bool flag=false;
    //在遍历全部数字时用代码屏蔽掉错误的年月日，也就直接屏蔽掉了不合法的数字
    //就不需要自己一个个拆分了
    for(i=n+1;i<=99999999;i++){
        year=i/10000;
        month=(i%10000)/100;
        day=i%100;
        a=i%10;
        b=(i/10)%10;
        c=(i/100)%10;
        d=(i/1000)%10;
        e=(i/10000)%10;
        f=(i/100000)%10;
        g=(i/1000000)%10;
        h=(i/10000000)%10;
        if(a==h&&b==g&&c==f&&d==e&&flag==false)
        //先输出下一个回文，如果第一个就是abab
        //那么两行一致，反正这个是一定先打印的！
        {
            if(check(year,month,day)){
                cout<<i<<endl;
                flag=true;//只输出一个回文
            }
        }
        if(a==h&&b==g&&c==f&&d==e&&a==c&&b==d){
            if(check(year,month,day)){
                cout<<i<<endl;
                break;
            }
        }
        //是哦，如果是下一个回文就是abab，那么两行就是一样的，并不是逻辑不严密
        //而是我的思维漏洞。反正无论怎么样，都是优先打印下一个回文，abab是回文的子集
        //放后面打印。如果第一个就是abab，那么两行一致，如果不是，那么abab也肯定要往下
        //查找！
        //并没有想到abab是回文的子集！

    }
    return 0;
}

//取模不会用很多时间
//优先暴力，超时再改
//即使超时我们也可以加多条件减少时间
//优化算法会增加代码量，我们不知道究竟超不超时可以根据题目难度来决定暴不暴力
//优先暴力，如果超时再优化算法，不要先优化，不然代码量多很容易出错，修bug麻烦而且步骤多
//容易出问题！先暴力试探一下底线，能过就不优化
//虽然繁琐但我也总算学会了如何优化算法
//记住，考试的时候是会不会做，不是叫你优化算法，能解决问题拿到分数就够了，不是让你最高效率
//因此你写多行代码是吃力不讨好的行为，尽量避免写过多行的代码（虽然有些重复的可以复制粘贴）
//优化代码对于题目理解就要更深刻，其次代码行数多写代码也费时间，而且没有必要的优化给自己的思维负担
//也大，耗费时间更长，更容易出错，因此，永远都是最短时间解题优先，能不优化就不优化，这是考量解题能力
//不是考你优化的能力！

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  char a[100000];
  long long sum=0;
  int set[30];
  scanf("%s",&a);
  long n=strlen(a);
  for(long i=0;i<n;i++)
  {
    sum+=(i+1-set[a[i]-'a'])*(n-i);
    set[a[i]-'a']=i+1;

  }
  printf("%lld",sum);

  return 0;
}

//年号字串
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
  // 请在此输入您的代码//
  //此题本质上是26进制考题，就是将十进制数字转换为对应的26进制字母，将每一位上的数字转换为对应的26进制字母即可
 int i,j,k,t;
 char a[26]={'Z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S',
 'T','U','V','W','X','Y'};
 //把Z放在前面，因为取模时会直接回到0，而且也解决了下标不对应的问题
    t=2019;
    //这里我们可以用26^n与t比对，看看n多大，然后确定有几位数
    i=t/676;
    j=t/26%26;//26进制字母，取整断尾，取模断头，锁定第二位数
    k=t%26;
    printf("%c%c%c",a[i],a[j],a[k]); 
  return 0;
}

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
 {long long i,tmp=0;
 long long a[3]={1,1,1};
  for(i=4;i<=20190324;i++)
  {
    tmp=a[0]+a[1]+a[2];
    a[0]=a[1];
    a[1]=a[2];
    a[2]=tmp;
    
  }
  printf("%lld",tmp%10000);
  //数据过大溢出了
// printf("0115");
  return 0;
}

//正解
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
 {long long i,tmp=0;
 long long a[3]={1,1,1};
  for(i=4;i<=20190324;i++)
  {
    tmp=(a[0]+a[1]+a[2])%10000;
    a[0]=a[1];
    a[1]=a[2];
    a[2]=tmp;
    
  }
  printf("%lld",tmp);
  //数据过大溢出了
// printf("0115");
  return 0;
}
//数据计算是符合叠加关系的
//对最后的结果保留最后四位数字==每一次的结果都保留4位数字
//所以直接取模就好了.

//迷宫


#include<bits/stdc++.h>
using namespace std;
char wz[50][55];
char d[4] = { 'D','L','R','U' };
// char dir[4][2]={{-1,0},{0,-1},{0,1},{1,0}};err
// char dir[4][2] = { {1,0},{0,-1},{0,1},{-1,0} };err
int dir[4][2] = { {1,0},{0,-1},{0,1},{-1,0} };
//这是数字不是字符，真的醉了
//你写的时候要知道你在干什么才行,不要乱贴标签
//往上走是相当于减一行，往下走是加一行！
struct node
{
    int x;
    int y;
    string s;
};

void bfs()
{
    //哪个node 哪个信息一定要指清楚！
    node next, now;
    queue<node>que;
    // wz[1][1]="1";err
    wz[1][1] = '1';
    //字符串用"",字符用''

    now.s = "";// s="";err麻烦你清楚是那个位置的s
    now.x = now.y = 1;
    que.push(now);
    //用条件与初始化条件分隔
    while (!que.empty())
    {
        now = que.front();
        que.pop();
        if (now.x == 30 && now.y == 50)
        {
            //  cout<<now<<endl;err
            cout << now.s << endl;
            //请指定你要输出什么！
        }

        for (int i = 0; i < 4; i++)
        {
            next.x = now.x + dir[i][0];
            next.y = now.y + dir[i][1];
              //下标的移动

            //  if(next.x>0&&next.x<=30&&next.y>0&&next.y<=50&&wz[next.x][next.y]=0)err
            if (next.x > 0 && next.x <= 30 && next.y > 0 && next.y <= 50 && wz[next.x][next.y] == '0')
                //是字符不是数字,还有是等价不是赋值
            {
                // wz[next.x][next.y]=1;err
                wz[next.x][next.y] = '1';
                //是字符不是数字

                next.s = now.s + d[i];
                que.push(next);

            }
        }


    }





}
int main()
{
    for (int i = 1; i <=30; i++)
        for (int j = 1; j <=50; j++)
        {
          // scanf("%s",&wz[i][j]);err
          //c语言的坏毛病，写scanf是错误输出,也不知道为啥可以通过编译器
            cin>>wz[i][j];
        }
    bfs();
    return 0;
}

#include <iostream>
#include <algorithm>
#include <string>
#include <string.h>
#include <queue>
///BFS+字符串
using namespace std;
#define maxn 50
int maze[maxn][maxn];
char d[4] = { 'D','L','R','U' };//注意，这里要按照字典序顺序排
int dir[4][2] = { {1,0},{0,-1},{0,1},{-1,0} };//这里的顺序要和上面d数组一一对应
int n=4, m=6;
struct node
{
    int x;
    int y;
    string s;
    /* data */
};
//每一次的循环都是只有一步，而且每轮都是要判断是否到达终点，
//因此也一定是最少步数，只要有点到了就会立马返回，典序一直都在判断，
//所以根本就不需要考虑步数最少，队列输出一定是最优解
//而且每一次都是从队尾，插入也有顺序，因此一定是最小的在最前面
void bfs()
{
    node now, next;
    queue<node> que;
    //默认队尾添加，队头删除
    //队列
    maze[0][0] = 1;
    now.s = "";
    now.x = now.y = 0;
    que.push(now);
    while (!que.empty())
    {
        now = que.front();
        //这里的now读取了数据,起到继承上一次的作用
        //给结点赋值
        que.pop();
        if (now.x == n - 1 && now.y == m - 1)
            //走到终点
            //从一开始的00一直到出口
            //n-1是因为从0开始插入
        {
            cout << now.s << endl;

        }
        for (int i = 0; i < 4; i++)
        {
            next.x = now.x + dir[i][0];
            next.y = now.y + dir[i][1];
            //行移动上下，列移动左右,相当于移动位置
            //确实只有这样才能移动
            // 行才能改变上下，列改变左右
            //改变行数和列数，等于移动坐标
            //每一轮都分别有上下左右的移动方式
            if (next.x >= 0 && next.x < n && next.y >= 0 && next.y < m && maze[next.x][next.y] == 0)
                //如果进不来这个条件，就自动读取不了next的记录，就直接完全删除了,就相当于无路可走，就退出了
            {
                maze[next.x][next.y] = 1;//记录走过
                next.s = now.s + d[i];
                //记录每种可能的字符串
                que.push(next);//队尾插入等待now继续向前探索
            }
        }
    }
}
//总的来说就是搜索，每一步讨论所有可能移动的方向，一个字符串保留数据。
//与循环不同就在于，每一轮都会删除上一次的结果，而合法数据得到继承，不合法就永久删除



int main()
{
   
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> maze[i][j];
        }
    }
    //这么写没问题的，你直接输入，即使存在数据，系统会帮你自动填写的
    //所以这是通用的
    bfs();
    return 0;
}

///BFS+字符串
#include<bits/stdc++.h>
using namespace std;
#define maxn 50
char maze[maxn][maxn];
char d[4] = { 'D','L','R','U' };//注意，这里要按照字典序顺序排
int dir[4][2] = { {1,0},{0,-1},{0,1},{-1,0} };//这里的顺序要和上面d数组一一对应
int n = 30, m = 50;
struct node
{
    int x;
    int y;
    string s;
    /* data */
};
//每一次的循环都是只有一步，而且每轮都是要判断是否到达终点，
//因此也一定是最少步数，只要有点到了就会立马返回，典序一直都在判断，
//所以根本就不需要考虑步数最少，队列输出一定是最优解
//而且每一次都是从队尾，插入也有顺序，因此一定是最小的在最前面
void bfs()
{
    node now, next;
    queue<node> que;
    //默认队尾添加，队头删除
    //队列
    maze[0][0] = '1';
    now.s = "";
    now.x = now.y = 0;
    que.push(now);
    while (!que.empty())
    {
        now = que.front();
        //这里的now读取了数据,起到继承上一次的作用
        //给结点赋值
        que.pop();
        if (now.x == n - 1 && now.y == m - 1)
            //走到终点
            //从一开始的00一直到出口
            //n-1是因为从0开始插入
        {
            cout << now.s << endl;

        }
        for (int i = 0; i < 4; i++)
        {
            next.x = now.x + dir[i][0];
            next.y = now.y + dir[i][1];
            //行移动上下，列移动左右,相当于移动位置
            //确实只有这样才能移动
            // 行才能改变上下，列改变左右
            //改变行数和列数，等于移动坐标
            //每一轮都分别有上下左右的移动方式
            if (next.x >= 0 && next.x < n && next.y >= 0 && next.y < m && maze[next.x][next.y] == '0')
                //如果进不来这个条件，就自动读取不了next的记录，就直接完全删除了,就相当于无路可走，就退出了
            {
                maze[next.x][next.y] = '1';//记录走过
                next.s = now.s + d[i];
                //记录每种可能的字符串
                que.push(next);//队尾插入等待now继续向前探索
            }
        }
    }
}
//总的来说就是搜索，每一步讨论所有可能移动的方向，一个字符串保留数据。
//与循环不同就在于，每一轮都会删除上一次的结果，而合法数据得到继承，不合法就永久删除



int main()
{
    //cin >> n >> m;根据需要来写
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            cin >> maze[i][j];
        }
    }
    //这么写没问题的，你直接输入，即使存在数据，系统会帮你自动填写的
    //所以这是通用的
    bfs();
    return 0;
}

//等差数列


#include <stdio.h>
#include <stdlib.h>
int n;

int tmp(const void*a,const void*b)
{
  return *(int*)a-*(int*)b;
}

int min(int a,int b)
{
  return a<b?a:b;
}
int main(int argc, char *argv[])
{
  scanf("%d",&n);
 int a[n];
 //10^9，int是够用的

  
  for(int i=0;i<n;i++)
  {
    scanf("%d",&a[i]);
  
  }
  qsort(a,n,sizeof(int),tmp);
  //排序类型！！别搞错了


   int d=a[1]-a[0];
  //用熟悉的字母更好
 for(int i=0;i<n-1;i++)//注意这里是n-1,因为最大只能是n-1
 {
   d=min(a[i+1]-a[i],d);
 }

 if(d==0)
 {
   printf("%d",n);
 }
 else
 {
   int sum=((a[n-1]-a[0])/d)+1;
 
  printf("%d",sum);
 }
  
  

  return 0;
}
//问题:1.没有考虑到d=0的情况
//2.以为一定是最小的数的前面两个d最小，实际上是
//每两个数之间都有可能存在最小的d,所以要比对两个数之间的d
//并选出最小的
//3.类型，不要混搭和错误，不然输出结果会错.
//包括使用的库函数，函数自己开的函数，还是计算，输入，全部都会牵连
//因此，一定先确定自己用什么类型，用了就尽量统一，不要变换，
//统一用一个不容易错。

//约数个数
#include <iostream>
using namespace std;
int main()
{
  int count=0;
  for(int i=1;i<=1200000;i++)
  {
    if(1200000%i==0)
    {
      count++;
    }
  }
  //1和自己本身也属于约数，0不属于约数
  cout<<count;
  return 0;
}

//激光样式

#include <iostream>
using namespace std;
 int get(int i, int j)
{
    return (i >> j) & 1;
}
 //每次移动j位，j-1位，&1，来判断是否两数都为1，如果条件为真.
 //flag就赋值假值，注意，当数字没有这么大的时候移动多的位数也是没问题的
 //都是0相当于关闭，也是合法的，因此&1不&0,&1只要是假值，自然return 0
 //条件为假flag就不变.
int main()
{
    long long sum = 0;//初始化！！！
    for (int i = 0; i < (1 << 30); i++)
        //1<<30为1左移三十位，相当于得到三十个数，大小为2^30(每个数出现0，1后进位，30个数)
        //因为计算机只有0，1，进制就相当于枚举，从000....1开始一直向三十位，可以穷举所有情况
        //从0开始代表所有都关闭时
    {
        bool flag = true;//bool判断真假
        //没有ture,只有true
        for (int j = 1; j < 30; j++)
            if (get(i, j) && get(i, j - 1))
            {
                flag = false;
                break;
            }
        sum += flag;//假值为0，加上等于没加，只有真值加了才有用，省去if判断
        //只有位置1，2/2，3/3，4...一直比到结尾，才能判断合法才能算一种情况
       
    }

    cout << sum;
    //结果为2178309
    //暴力算法，填空结果正确就行了，程序运行慢就让它慢慢在编译器里跑，最后输出结果就行了
    return 0;
}
//法二
#include <iostream>
using namespace std;
int main()
{
  //递推
    int dp[50][2];
    //前面为数字位数，后面表示0或者1

    dp[1][0] = 1;
    dp[1][1] = 1;
    //初始赋值，表示为1种情况

        for (int i = 2; i <= 30; i++)
        {
            dp[i][0] = dp[i - 1][0] + dp[i - 1][1];
            dp[i][1] = dp[i - 1][0];
    }//从第二个数位开始，讨论两种情况，为0时后面的第一个数位0或1都可以
    //为1时只能为0，数组反复赋值每次都会将前面所有的数位结果叠加，所以最终
    //输出最后的数组即可.
    
        cout << dp[30][0] + dp[30][1] << endl;
  return 0;
}

//四平方和
#include <bits/stdc++.h>
using namespace std;
int main()
{
  int n;
  scanf("%d",&n);
  for(int i=0;i*i<=n;i++) 
  for(int j=i;i*i+j*j<=n;j++)
  for(int k=j;i*i+j*j+k*k<=n;k++)
  for(int l=k;i*i+j*j+k*k+l*l<=n;l++)//条件要写==，本身也是考虑在内的
  if(i*i+j*j+k*k+l*l==n)
  {
     printf("%d %d %d %d",i,j,k,l);
     return 0;

  }

  //程序不是提前预设时间复杂度的，而是实打实的根据结果得出的
//优化循环的条件,将循环次数降低，因为如果每次都遍历到最大，很可能比如
//i*i+j*j+k*k+l*l早已大过n了还在那里傻傻的遍历，等到这层循环结束.而如果控制每次循环一旦比n大
//我就退出循环就规避了无效遍历。
//而前面每次都少一个意思就是判断只有前面的数之和没有超过n我才需要进入下一个循环，
//如果超过了就需要更新前面的新的数字，也同样是避免了大量的无效循环，
//因此循环条件的设置也是能大大优化for的时间复杂度的.
 
  return 0;
} 
//优化循环条件，优化遍历次数

#include <iostream>//最长递增
using namespace std;
int main()
{
  int n;
  int a[10000];
  int cnt=0,m=0;
  cin>>n;
  for(int i=0;i<n;i++)
  {
     cin>>a[i];
  }

  for(int i=1;i<n;i++)
  {
       if(a[i-1]<a[i])
       {
          cnt++;
       }
       else
       {
         m=m>cnt?m:cnt;
         cnt=1;
       }

  }
  //这里只需要判断一次是因为只有从最开始遍历的时候才是最长的，出现了不是递增的情况
  //就表示结束了就截断，开始下一个序列的遍历。
  cout<<m;
  
  return 0;
}

#include <stdio.h>//连号区间数
#include <stdlib.h>
long long INF=1e9;
 
int max(int a,int b)
{
  return a>b?a:b;
}
int min(int a,int b)
{
  return a<b?a:b;
}//c++可以直接不写比较大小函数，有现成的
int main(int argc, char *argv[])
{
   int n;
   int p[1000000];
   long long res=0;
   scanf("%d",&n);
   for(int i=0;i<n;i++)
   {
     scanf("%d",&p[i]);
   }
 
   for(int i=0;i<n;i++)
   {
      int maxv=-INF,minv=INF;
     for(int j=i;j<n;j++)
     {
      //  int max=-INF,min=INF;err
      //注意摆放位置，是每次左边界的一开始给max，min附上第一个数
      //   min=(min,p[j]);
      // max=(max,p[j]);函数都不用写了是吧？
      //为了避免和函数混淆，取名字特意改一下
 
       minv=min(minv,p[j]);
      maxv=max(maxv,p[j]);//迭代
      
      //左边界没有变的时候，每次都保留这次的minv与maxv
      //然后跟最新的数字比较，有更好的就更新，没更好的就保留
      //避免重复遍历.
 
       if(maxv-minv==j-i)
       {
         res++;
       }
     }
   }
 
   printf("%lld",res);
  return 0;
}
//不能给p排序，因为题目说的是排序后可以得到，而不是让你排序
//你排了序选定的数字位置都不一样了，是选定后排，而不是先排后选定
//所以不需要给输入的数字排序

//k的倍数==前缀和的相同余数之差的总共情况+前缀和本身的情况.

//思路:前缀和+余数相等，前缀余数相等时，相减前缀就能得到有效的k倍区间
//(因为他们余数相等，相减的时候恰好将他们的余数消去可以把前缀比作
//nk+mod,mod是/k后留下的余数，nk1+mod-(nk2+mod),相减就只留下k。
#include <iostream>
using namespace std;
int main()
{
  int n,k,a;
  cin>>n>>k;
  long long sum=0,ans=0;
  //当前前缀和      总共情况
  int mod[100000];//统计余数相同时的次数

mod[0]=1;//初始化余数为0时余数记为1是因为余数为0时
//自己本身这个区间也算k的倍数，所以要多1，本身这种情况只有1次
//所以只加1,而后与其他余数相同，余数==0时前缀和相减也是一种情况.
for(int i=1;i<n;i++)
{
  mod[i]=0;
}//自身情况不算所以初始值为0
  for(int i=0;i<n;i++)
  {
    cin>>a;
    sum+=a;//每次都扩大1次前缀
    ans+=mod[sum%k];
    //对前缀取余，加上前面相同余数的情况，
    //相当于直接得到相减的步骤，
    //即当前的前缀减去前面所有相同余数前缀的结果
    //这里都是前缀相减的结果，不包含自身前缀本身
    //只有mod[0]时才是自身情况也算上
    mod[sum%k]++;
    //加上这一次的前缀的余数情况.

  }
  cout<<ans;//记得输出结果，调试如果只是答案错误但是什么输出都没有就表示你没打印结果！
  //一定要注意，不然白做！
  return 0;
}
//取余+相减==k的倍数，所以倍数题目一般都用取余
//如果不清楚自己的结论是否正确，可以自己写测试数据检测一下或者
//列举简单的数字看看结果是否相符，来判断是否程序正确或健全.


#include<bits/stdc++.h>//递增三元组

using namespace std;
int main()
{
  int a[100000],b[100000],c[100000];
  int n;
  long long ans=0;
  cin>>n;
  for(int i=0;i<n;i++)
  cin>>a[i];
  for(int i=0;i<n;i++)
  cin>>b[i];
  for(int i=0;i<n;i++)
  cin>>c[i];

  sort(a,a+n);//直接写出首尾就ok了
  sort(c,c+n);

  int left,right;
for(int i=0;i<n;i++)//枚举b
{
  //找出比b小的最大的a,比b大的最小的c
   left=0,right=n-1;
   while(left<right)
   {
     int mid=(left+right+1)/2;
     if(b[i]<=a[mid])//当前a的值大于等于b，我也不要了
     //a太大，我就缩小
     //注意，这个小于等于要放在一起因为都归为mid不可取的一边
     //如果只写<，那么等于在下面就无法把等于这种情况去除.
     right=mid-1;
     else
     left=mid;//当前mid满足条件可取

   }

  int x=right;
 left=0,right=n-1;
while(left<right)
{
  int mid=(left+right)/2;
  if(b[i]>=c[mid])//条件不满足题意，mid值不要
  left=mid+1;
  else
  right=mid;//符合,mid可取

}
int y=right;

if(a[x]<b[i]&&b[i]<c[y])
{
      // ans+=(x+1)*(n-y);err
       ans+=(long long)(x+1)*(n-y);
      //两个相乘是因为排列组合
      //定下1个b，每一种a都有n-y个c的情况.
      //一个数据错了，这里相乘计算大数据会溢出
      //所以要扩大数据类型！
      //但是给x,y修改类型竟然也能过，我不知道为什么
      //但逻辑来讲还是改这里的数据类型比较严谨
}



}

cout<<ans;

return 0;
}

#include <iostream>//积木
using namespace std;
int main()
{
    int n, m, x, h, hmax = 100000, sum = 0;
    int num[100005];
    long long ans = 0;
    cin >> n >> m;

    for (int i = 0; i < n * m; i++)
    {
        cin >> x;
        if (x > hmax)
            x = hmax;
        if (x)
        {
            num[x]++;
            sum++;
        }
    }
    //水上升高度上限是题目输入的，不是题设最大，还是看题！

    cin >> h;
    for (int i = 1; i <= h; i++)
    {
        ans += sum;
        cout << ans << endl;
        sum -= num[i];
    }

    // cout<<ans;err
    //没看题目，别无脑最后打印行不行，看题目要求！
    return 0;
}


#include <bits/stdc++.h>//倍数问题
using namespace std;
int n,k; 
int group[1010][3];//??
//这个group不能放在for循环中,
//要么放在主函数开头，要么放全局变量
//你在for循环定义数组，就会反复因为循环刷新这个数组，
//以后不要在循环中定义变量/数组，除非只是暂时使用的！
//要记录数据就一定要放在全局或者主函数开头
int main()
{
  
 
  cin>>n>>k;
  for(int i=0;i<n;i++)
  {
    int num;
    cin>>num;
    int re=num%k;
    
    if(num>group[re][0])
    {
      group[re][2]=group[re][1];
      group[re][1]=group[re][0];
      group[re][0]=num;
    }
    else if(num>group[re][1])
    {
      group[re][2]=group[re][1];
      group[re][1]=num;
    }
    else
    {
      group[re][2]=max(group[re][2],num);
    }
 
  }
 
 
int ans=0;
  for(int x=0;x<=k;x++)
  {
    for(int y=x;y<=k;y++)
 {
   int z=(k+k-x-y)%k;
   int v1=group[x][0];
   int v2,v3;
 
if(y==x)
{
  v2=group[x][1];
 
  if(z==y)
  {
     v3=group[x][2];
  }
 
  else
  v3=group[z][0];
 
}
else
{
  v2=group[y][0];
  if(z==x)
  {
    v3=group[x][1];
  }
  else if(z==y)
  {
    v3=group[y][1];
  }
else
{
    v3=group[z][0];
}
 
  
 
}
 
if(v1+v2+v3>ans)
ans=v1+v2+v3;
   
 }
 
  }
 
 
 cout<<ans<<endl;
  return 0;
}

#include <iostream>//冰雹数，线性思维没啥好说的
using namespace std;
int main()
{
  long long n,m;
  //不知道它上升的时候会不会溢出
 cin>>n; 
  m=n;//输入的最大数字是初始时的最大情况

  for(int i=1;i<=n;i++)//不大于n的所有数字中的最高情况
  {
    long long j=i;
    while(j!=1)
{
  if(j%2==0)
  //&符号要括起来，避免计算机无法确认计算优先度
  {
    j/=2;
  }
  else
  {
    j=j*3+1;
    //j>>=1也行,右移一位等于除以2
  }
   
   if(j>m)
   m=j;
}


  }
cout<<m;
  return 0;
}

#include <iostream>//成绩统计
using namespace std;
int main()
{
  int n,maxv=0,minv=200,sum=0,a;
  cin>>n;
  for(int i=0;i<n;i++)
  {
    cin>>a;
    maxv=max(maxv,a);
    minv=min(minv,a);
    sum+=a;
  }
  float ans=1.00*sum/n;

printf("%d\n%d\n%.2f\n",maxv,minv,ans);
//注意上面的结果要*1.00表示保留，下面.2表示截取，都要写
  
  return 0;
}
 
 #include <bits/stdc++.h>//砍竹子
 using namespace std;
 typedef long long ll;
 int main()
 {
   int n,m=0;
   ll skr[50];
   ll f[200010][50];
   ll h,res=0;
   cin>>n;
   int i;
   for(i=0;i<n;i++)
   {
     cin>>h;
     int top=0;
     while(h>1)//h==1不需要变魔法， 直接不参与统计
     {
        
       skr[++top]=h;
       //下标1对应初始长度是因为我们舍去了h==1的考虑
       //照理应该是skr[topmax]=1,可是我们直接不要了
       //但又要有正确的变魔法次数，所以数组下标统一后移
       //同时也满足skr下标对应了top
  
      //为了保险起见，下标最好初始化不为负数，防止数组越界，一定不要赋值下标初始为-1
         h=sqrtl(h/2+1);
      }
     // cout<<top<<endl;
      //如果不确定结果是否正确可以自己先打印出数据看看核对是否程序无误
      //不是最终结果，其中的一部分也是可行的
     res+=top;
     m=max(m,top);
     //得出最大的使用魔法次数，用于接下来，比对满足使用了相同次数的魔法的竹子，
     //省去了很多没必要比对的竹子，大大节省时间.
  
    for(int j=0,k=top;k;j++,k--)
   //此时最终满足对应下标而且不会越界，直接插入即可
    {
      f[i][j]=skr[k];//正序插入到数组
    }
     
  
   }
  
     for(int j=0;j<m;j++)//使用魔法的次数先固定，先比对不同的竹子
     //不需要等于m,m次数最大时竹子都砍完了，不会再变魔法了
     //所以都是在变魔法之前判断竹子是否相等
     for(int i=1;i<n;i++)
     {
       // if(f[i][j]==f[i-1][j])err
       if(f[i][j]&&f[i][j]==f[i-1][j])//要保证j中有数据才能比较
       //没有数据的比较会使得程序出错
       res--;
     }
  
 cout<<res<<endl;
  
  
   return 0;
 }
 
 //数的分解
 #include <iostream>
 using namespace std;
 int main()
 {
   int i,j,k;
   long long countv=0;
   for(i=1;i<=2019;i++)
   {
     int t =i;
     while(t)
     {
       if(t%10==2||t%10==4)
       break;
 
       t/=10;
     }
 
     if(t==0)
     {
     for(j=i+1;j<=2019;j++)
   {
     t=j;
     while(t)
     {
       if(t%10==2||t%10==4)
       break;
 
       t/=10;
     }
     if(t==0)
     {
       k=2019-i-j;
       t=k;
     while(t)
     {
       if(t%10==2||t%10==4)
       break;
 
       t/=10;
     }
 
     if(t==0)
     {
       if(i < j && j < k)//这个条件很重要！
       //我们定义这三个各不相同的正整数为 i, j, k 并且必须满足 i < j < k 。这样就不存在交换任意俩个导致计算重复了。
       //因为开始时k最大，i最小，
       //所以实际上只需要一直保持着i<j<k即可
       //如果i比j大了，就相当于i和j换了位置是重复的情况
       //,会出现交叉的方法
       //k也同理，所以控制i,j,k只有一种情况的大小情况即可
       countv++;
     }
 
     }
 
   }
     }
   }
   //虽然写完才发现可以用函数代替重复步骤，下次注意
   //重复调用步骤用函数不要自己硬生生地复制粘贴，不简洁还容易错
   
   
   cout<<countv;
 
   return 0;
 }
 //优化
 #include <stdio.h>
 #include <stdlib.h>
 int judge(int n)
 {
   while(n)
   {
     if(n % 10 == 2 || n % 10 == 4)
     {
       return 0;
     }
     n /= 10;
   }
   return 1;
 }
 int main(int argc, char *argv[])
 {
   int i, j, k;
   int ans = 0;
   for(i = 1; i <= 2019; i ++)
   {
     for(j = 1; j <= 2019; j ++)
     {
       k = 2019 - i - j;
       if(judge(i) && judge(j) && judge(k))
       {
         if(i < j && j < k)
         {
           ans ++;
         }
       }
     }
   }
   printf("%d\n", ans);
   return 0;
 }
 
 #include <bits/stdc++.h>//大胖子走迷宫
 using namespace std;
 int dp[310][310];//插入地图
 int vis[310][310];//标记走过的位置
  
 //地图和走过的位置还是要区分开最佳，不然比如胖子
 //识别是否有障碍的时候，走过的标记和障碍会冲突
  
 //广搜核心:每一次都遍历了所有的情况，因此可以遍历所有的结果
 //配合队列，队列的插入和删除保证为最佳情况（最短时间)
 //以及队列能够使用出队来删去不满足条件的情况，减少无效遍历
 //使用入队来实现继承满足条件的情况,继续遍历
  
 int n,k,stage;
 int dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}};//四个方向
  
 struct node
 {
   int x;//行方向
   int y;//列
   int step;
 };
 //使用的时候自己命名一个node 的变量使用即可
 queue<node>q;
  
 int check(int x,int y)
 {
   for(int i=x-stage;i<=x+stage;i++)
   for(int j=y-stage;j<=y+stage;j++)//又给我忘记等号！
   //写循环时一定要判断等号要不要！
   {
       if(dp[i][j]==1)
       return 0;
   }
  
  return 1;
 }
 //判断每个前进方向的那一排是否有障碍这么讨论太麻烦
 //换成自身周围是否有障碍更简单
 //周围没障碍我就只管往四方走。轮到下次判断
 //自身周围是否有障碍来检测这种情况的合法性
 //有时候思维不要过于直接，一种思路过于复杂可以试试
 //另一种方式思考
 void bfs()
 {
   vis[3][3]=1;//表示走过
   node now,next;//分现在和下一步的情况
  
   //注意next结点可以任意修改，但是now结点不能动,动了就全错
  
   now.x=now.y=3;//不要忘记初始化结点！
  now.step=0;
  //开局一定要注意插入第一个元素，
 //不然循环进不去!
 q.push(now);
  
   while(!q.empty())
   {
    
     now=q.front();
     q.pop();
     if(now.x==n-2&&now.y==n-2)//遍历结尾
     {
       cout<<now.step<<endl;
       // return 0;
       //void 函数不要return 0;
       return;
     }
    
    if(now.step<k)//用选择次数代替时间,用step(每次的选择走哪时间也是增加1次，所以直接用)
      stage=2;//表示还是大胖子
     else if(now.step>=k&&now.step<2*k)
       stage=1;
         else
       stage=0;
  
  
       if(stage>0)//原地踏步，stage=0就不可能原地踏步
       //原地踏步的选择为下一步，不要投机取巧想着改一个step
  
       //你的一个地方的错误就会导致全盘错误，不要顾此失彼
       //因小失大！
       {
         // now.step=now.step+1;err
         //不能这么写，你这么写就改变了现在now的长度,
         //影响了后面的step的正确输出
        // 所以说还是分类最好.下一步归下一步，思路清晰不偷懒
          next.step=now.step+1; 
           next.x=now.x;
           next.y=now.y;
         q.push(next);
       
         
         
       }
       
       for(int i=0;i<4;i++)
       {
         // next.x=now.x+dir[0][i];
         // next.y=now.y+dir[1][i];
          next.x=now.x+dir[i][0];
         next.y=now.y+dir[i][1];//四个方向讨论
         //列放了两个元素，分别四个方向
         //方向应该放在行，元素放在列，
         //其中一个元素为0是为了区分是移动y还是移动x
         //这么写很简洁，就一个循环都能实现x与y的移动
         //原理是动x的时候y不动即y+0;
         //动y不动x,x+0;
         //同时注意统一x,y方向(x一个下标,y一个)
         if(!check(next.x,next.y)||vis[next.x][next.y]||next.x-stage<1||next.y-stage<1||next.x+stage>n||next.y+stage>n)
         //    周围是否有障碍         是否走过                            是否已经超出迷宫
          continue;
         //设置边界,排除非法情况
       //  next.step++;不要这么写，会重复增加
         next.step=now.step+1;//跟前面一样每次拿now结点就不会出错
         //增加移动距离
         
         vis[next.x][next.y]=1;//别忘了标记走过！
         q.push(next);
         
  
        
       }
  
     
    
   
  
    
     
   }
 }
   
 int main()
 {
  
   cin>>n>>k;
  char c;
 for(int i=1;i<=n;i++)
 for(int j=1;j<=n;j++)
 {
   cin>>c;//输入每次的符号
   if(c=='+')
   dp[i][j]=0;
   else
   dp[i][j]=1;//1表示有障碍
   //将字符换成1，0，方便快捷
 }
  
 bfs();
  
   return 0;
 }
  
  
  #include <iostream>//七段码
  using namespace std;
  int e[10][10];
  int ans=0;
  int st[10];
  int p[10];
   
  int find(int x)
  {
    if(p[x]!=x)
    {
        // find(p[x]);err
       p[x]=find(p[x]);
       //光找父节点是不够的，还要将此时的节点换成父节点才行
       
       //p用于存放和接收、返回最终结果.
       //首先先从1开始,一直找,1-2-6
       //p[6]=6,return 返回,p[2]接收p[6]
       //再由p[2]返回,p[1]接收，最终得到p[1]=6;
    }
   
  // else
  //???
  //为什么加else会出错
  //理解程序
  //dfs是一直向下搜索的直到搜索到结果位置
  //如1-2-6,6为结果,那么p[6]=6的结果就要返回给
  //p[2],p[2]=6,然后p[2]已知才能返回给p[1]
  //于是p[1]=6
  //如果你加了else,那就没有办法返回给p[2],p[1],就出错了
   
   return p[x];
   
   
   
  }
   
  void dfs(int u)
  {
    if(u==8)
    {
      for(int i=1;i<=7;i++)
      {
         p[i]=i;
      }
       
      for(int i=1;i<=7;i++)
      for(int j=1;j<=7;j++)
      {
        if(st[i]&&st[j]&&e[i][j])
        {
          p[find(i)]=find(j);
          //p用于储存上一次的父节点,find(j)寻找是否有新的父节点
   
          //每一次的改变父节点，也就是节点相连
          //就表示两个管的相连
          //全部都连在一个父节点就表示所有两个管相连的合并
          //即所有管相连的表示。
          
          //如果所有的管都能相连，那最终肯定是只有一个父节点的
          //(因为一个父节点的时候，所有开始的父节点相连变成了节点
          //连接在最后的那个父节点上)
   
          //只有有灯管不能相连，才能有多个父节点
          //(因为不能相连，就无法改变那个初始的父节点,那个父节点一直都是独立的)
   }
   
      }
   
   int cnt=0;
    for(int i=1;i<=7;i++)
    if(st[i]&&p[i]==i)
    {
      cnt++;
    }
   
    if(cnt==1)
    {
      ans++;
      // return;err//不要写在if里面，你无论增不增加都是要退出函数的
      //不然就死循环了！
    }
   
   
   
       return;
      
   
   
    }
    
    st[u]=1;
    dfs(u+1);
   
    st[u]=0;
    dfs(u+1);
   
  }
   
  int main()
  {
    
    e[1][2]=e[1][6]=1;
    e[2][1]=e[2][7]=e[2][3]=1;
    e[3][2]=e[3][7]=e[3][4]=1;
    e[4][3]=e[4][5]=1;
    e[5][4]=e[5][7]=e[5][6]=1;
    e[6][1]=e[6][7]=e[6][5]=1;
    e[7][6]=e[7][2]=e[7][3]=e[7][5]=1;
   
    dfs(1);
   
    cout<<ans<<endl;
      return 0;
  }
   
  //dfs的return一般是不加条件的！放在末尾退出或者返回值
  //不要随便加条件干预！放结尾直接return就好
  
  
