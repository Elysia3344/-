//尝试DFS失败了
// 
//#include<iostream>
//#include<string>
//using namespace std;
//作为一个城市的紧急救援队队长，
//你会得到一张你国家的特殊地图。
//该地图显示了几个由一些道路连接的分散城市。
//每个城市的救援队数量以及任何一对城市之间的每条道路的长度都在地图上标出。
//当有来自其他城市的紧急电话给你时，你的工作是尽快带领你的人到那个地方，
//同时，在路上尽可能多地召集人手。   输入规范：每个输入文件包含一个测试用例。
//对于每个测试用例，第一行包含 4 个正整数：N （≤500）
//- 城市数（城市编号从 0 到 N−1），M - 道路数，
// C 1 和 C 2 -您当前所在的城市和您必须保存的城市。下一行包含 N 个整数

//其中第 i 个整数是第 i 个城市的救援队数量。然后是M条线，每
//条线用三个整数c1，c 2和L描述一条道路，
//它们分别是由道路和该道路长度连接的城市对。
//保证至少存在一条从 C 1 到 C 2 的路径。
//输出规格：对于每个测试用例，
//在一行中打印两个数字：C 1 和 C 2 之间不同最短路径的数量，
//以及您可以收集的最大救援队数量。
//一行中的所有数字必须正好用一个空格分隔，并且行尾不允许有额外的空格。   示例输入：

//int flag2, n, m, flag1, c1, c2, L, maxc = -1e9, cnt = 0;//必须救援的城市，相当于终点
//int road[510][510] = { 0 };
////根据示例可以看出是不能够重复走过一个城市的！
//void dfs(int now)
//{
//	if(now==maxc&&road[now][flag2] == 0)
//	{
//		
//		return;
//	}//出口
//
//    
//
//	for (int i = 0; i < maxc; i++)
//	{
//		if (road[now][i] != 0)
//		{
//			if (road[now][i])
//			{
//          maxv = max(maxv,cnt);
//		  return;//就是直接剪枝，
//		}
//			
//            cnt += road[now][i];
//			dfs(i);
//			
//			
//		}
//	}
//
//
//}
////模糊，不知道怎么设置剪枝，想着插入当前的路线长度，但是设置终点不清晰.
//int main()
//{
//	int a[510] = { 0 };//统计当前人数
//	int save[510];//救援队数量
//	 
//	//        起点   
//		//方向不可逆
//	cin >> n >> m >> flag1 >> flag2;
//	for (int i = 0; i < n; i++)
//	{
//		cin >> save[i];
//	}
//
//	for (int i = 0; i < m; i++)
//	{
//		cin >> c1 >> c2 >> L;
//		maxc = max(maxc, c1, c2);
//		road[c1][c2] = L;
//
//	}
//
//	dfs(flag1);
//	int a[i] += L[i];
//	
//	//选出后在做比较
//	minv = min(minv, L[i]);
//	sort(q, q + n);
//	for()
//		if (q[i] == q[0])
//		{
//			cnt++;
//		}
//
//
//	cout << cnt<<" "<< maxv << endl;
//
//
//
//	return 0;
//}

//	分析为何行不通：
// DFS只能有一种条件，要么最短要么最长，它没有办法同时兼并很多个条件，剪枝特别麻烦，一般来说线性的直白的才好用DFS
// 而dijkstra算法就可以设置多个条件并且能实现所有情况的遍历。




//解题过程
//作为一个城市的紧急救援队队长，
//你会得到一张你国家的特殊地图。
//该地图显示了几个由一些道路连接的分散城市。
//每个城市的救援队数量以及任何一对城市之间的每条道路的长度都在地图上标出。
//当有来自其他城市的紧急电话给你时，你的工作是尽快带领你的人到那个地方，
//同时，在路上尽可能多地召集人手。   输入规范：每个输入文件包含一个测试用例。
//对于每个测试用例，第一行包含 4 个正整数：N （≤500）
//- 城市数（城市编号从 0 到 N−1），M - 道路数，
// C 1 和 C 2 -您当前所在的城市和您必须保存的城市。下一行包含 N 个整数

//其中第 i 个整数是第 i 个城市的救援队数量。然后是M条线，每
//条线用三个整数c1，c 2和L描述一条道路，
//它们分别是由道路和该道路长度连接的城市对。
//保证至少存在一条从 C 1 到 C 2 的路径。
//输出规格：对于每个测试用例，
//在一行中打印两个数字：C 1 和 C 2 之间不同最短路径的数量，
//以及您可以收集的最大救援队数量。
//一行中的所有数字必须正好用一个空格分隔，并且行尾不允许有额外的空格。   示例输入：
#include<iostream>
#include<string>
using namespace std;
int n, m, c1, c2, L, st, ed, inf = 1e9;
const int maxn = 510;	
int save[maxn], num[maxn], d[maxn], w[maxn];//不赋值数组自动是0
/*int g[maxn][maxn] = { inf };*///这么写只能赋值一个下标，还是得用fill;err
int g[maxn][maxn];
bool vis[maxn] = { false };//bool类型可以这么写
void dijkstra(int s)
{  
	fill(d, d + maxn, inf);//为保证开始能导入d[s]为起点还有连接起其他所有的城市，必须先赋很大的值
	num[s] = 1;//用于连接开始的num[c2]=num[c1]
	w[s] = save[s];//初始的城市救援队给我漏了！
	d[s] =0;//起点距离为0;
	//初始化
	//在程序的遍历中会将后面的距离，人数还有路线数量等信息补全
	//但是一开始的基础数据一定要写出来！初始状态的条件一定不能漏！！！
	//这是继承探寻补齐数据的基础，务必记得写出初始状态的条件！

	for (int i = 0; i < n; i++)
	{
		int c1 = -1, min = inf;
		for (int j = 0; j < n; j++)
		{
			
			if (vis[j] == false && d[j] < min)
				{
					c1 = j;
					min = d[j];
				}
				
		}
		if (c1 == -1)
			return;
		vis[c1] = true;

		for(int c2=0;c2<n;c2++)//是下一个城市的探寻，也是所有城市作为终点的最短路径的计算.
		{
			if (vis[c2] == false&&g[c1][c2]!=inf)
			{
				if (d[c1] + g[c1][c2] < d[c2])
				{
					d[c2] = d[c1] + g[c1][c2];
					w[c2] = w[c1] + save[c2];
					num[c2] = num[c1];

				}

				else if (d[c1] + g[c1][c2] == d[c2])
				{
					if (w[c1] + save[c2] > w[c2])
					{
						w[c2] = w[c1] + save[c2];
					}

					num[c2] += num[c1];
				}
			}
			
		}


	}
}
int main()
{
	

	cin >> n >> m >> st >> ed;
	for (int i = 0; i < n; i++)
	{
		cin >> save[i];
	}
	
	fill(g[0], g[0] + maxn * maxn,inf);

	for (int i = 0; i < m; i++)
	{
		cin >> c1 >> c2 >> L;
		g[c1][c2] = L;
		g[c2][c1] = g[c1][c2];

	}

	dijkstra(st);

	cout << num[ed] << " " << w[ed];












	return 0;
}

//详解
//思路：更新当前的最短路径->更新抵达剩下所有城市的路线，如有更小就换掉;相等就增加救援人数和最短路线->枚举剩下所有城市的路线后
// 就可以继续选出下一次的最短路径，如此循环.
// (只有每一次都枚举剩下所有城市的路线，你才知道哪一条才是最短路径)
//本质其实就是枚举每一条路径的各种可能，选出最短路径的走法
//题意转化：最短路径=每次选择当前最短的一条路

//重要备注
//1.num[x]代表所有到x位置的最短路径的线段个数
//样例说明C1,C2的最短路径意思是总长度，
//如0->1,1->2,与0->2是同样最短（结合样例读懂题目很重要)
//题目优先最短路径，然后选择最多人数的路径
//将u放到v是因为u被标记而v未标记.
#define _CRT_SECURE_NO_WARNINGS
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn = 510;
const int inf = 1000000000;

int n, m, st, ed, G[maxn][maxn], weight[maxn];
int d[maxn], w[maxn], num[maxn];
//        最多救援队数量        最短路径数量
bool vis[maxn] = { false };


void dijkstra(int s) {      //memset和fill的区别
	fill(d, d + maxn, inf);//fill在头函数algorithm里面，可以赋任何值，而memset
	memset(num, 0, sizeof(num));//err//对int数组来说，只能赋0或-1
	memset(w, 0, sizeof(w));
	d[s] = 0;//起点距离为0
	w[s] = weight[s];//这里的权重是经过一个城市可以带的人数
	num[s] = 1;
	//初始化

	//u是当前点，v是下一个点
	for (int i = 0; i < n; i++) //轮数，每一次标记一个城市表示走过。
	{
		int u = -1, min = inf;
		for (int j = 0; j < n; j++) //找当前点最短路径下标
			//这个当前点的范围在那些未被探寻的城市中
			//即确定当前选择哪一个城市的路径是最短的
		{
			if (vis[j] == false && d[j] < min) {
				u = j;
				min = d[j];//min为u服务
			}
		}
		if (u == -1)
			return;//每个点都被探索完后，直接退出函数

		vis[u] = true;//防止重复路径就标记
		//每选出一个当前最短路径作为起点，就标记一次
		//代表从当前点开始，以后不能重复走回这个城市
		//标记走过的同时也是相当于自己到达终点时的路线
		//每一次的标记也代表着沿着这个这些城市向前走，
		//每一次都选择最短的路线
		//标记代表走过，避免重复探索
		//同时也是确定了自己的行走路线.


  //标记过的点不会再被探寻，也就意味着接下来比较的
//都是未被探寻的城市的最短路径，也就相当于在当前城市去寻找未被探寻的城市中最短路径
		for (int v = 0; v < n; v++)//将每个下一个的城市都换为最短的路径
			//只有每个点都是最短路径，才能实现遍历所有的城市
			//使用继承的时候才能继承所有的情况
			//比如我们要求最终到2城市的最短路径，我们就要考虑上一个城市的位置
			//枚举所有的城市，那么怎么实现最短，就必须要在之前求出他们所有城市的最短路径
			//然后再选择一个上一个城市中最短路径的那一条
		{
			if (vis[v] == false && G[u][v] != inf)
				//下一个城市的选择必须是没走过的，题意不能重复走一条路
			{
				if (d[u] + G[u][v] < d[v]) {//迭代

					d[v] = d[u] + G[u][v];//更换最短路径
					w[v] = w[u] + weight[v];//增加队伍人数
					//继承w[u]在加上自己城市的人数，因为一开始w空.
					num[v] = num[u];//只有d[u] + G[u][v]和d[v]
					//更换最短路径的数量

				}
				//每一次的比对都是当前城市u和下一个城市v之间的路径
				//一旦出现更短的就换成更短的最短路径的数量
				//G[u][v]这个是不是最短的路径先不用管，等到下一次
				//当前城市的时候自然会讨论到，现在只关心u和v;

				//不要分割思维去求每一个量。
				// 更换路径和增加人数，
				//最短路径的确定还有数量都在一个循环和if中实现
				//能写在一起就写在一起.


				else if (d[u] + G[u][v] == d[v]) { //相等的时候才会有不同路径，才增加最短路径的条数
					if (w[u] + weight[v] > w[v]) {//路径同样最短的时候，选人数最多的路线走.
						w[v] = w[u] + weight[v];
					}//但是每过一个节点，权重就会增加
					num[v] += num[u];//？？
					//num[v]还是num[u]都是代表着这条路
					//因为已经核对过d[u] + G[u][v] == d[v]
					//证明num[u]这条路是可以的,
					//意思就是只要d[u] + G[u][v] == d[v]
					// 那我们就只用找num[u]的条数就行了（因为当前位置是最短或者相等的）
					//又因为只有路径大小num才会增加
					//所以就是num[v]加上u位置的所有条数
					//d[u] + G[u][v] < d[v]同理


				}
			}
		}
	}
}

int main() {
	scanf("%d%d%d%d", &n, &m, &st, &ed);

	for (int i = 0; i < n; i++) {
		scanf("%d", &weight[i]);//救援队
	}

	int u, v;
	fill(G[0], G[0] + maxn * maxn, inf);
	for (int i = 0; i < m; i++) {
		scanf("%d%d", &u, &v);
		scanf("%d", &G[u][v]);
		G[v][u] = G[u][v];//这一定要G[v][u]=G[u][v]
	}           //刚开始写错了，写成G[u][v]=G[v][u],输出为0
	//正反大小一样
	//输入路径长度



	dijkstra(st);
	printf("%d %d\n", num[ed], w[ed]);
	return 0;
}

//经验：多开数组，来存放不同位置的信息，还有更新信息。