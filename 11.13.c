#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h> 
#include<string.h>
#include<math.h>
int main()
{
	//double a = 5 / 2.0;
	//printf("%lf\n", a);
	
	//int a = -1;
	//int b = a >> 1;
	//printf("%d", b);
	///*存储到内存的是补码，所以移动时是移动补码，但结果呈现的是原码，所以要自己转换
	//	正整数的原码补码反码都一样
	//	而负数就需要转换.*/
	////10000000000000000000000000000001
	////11111111111111111111111111111110
	////11111111111111111111111111111111

	//int a = 5;
	//int b = a << 1;
	//printf("%d", b);
	////正整数直接移动，负数要先转换成补码，移动，再转回源码
	////&按位与：二进制对应同1才为1，不同取0；
	////|或，有1就是1，没有取0
	//int a = 3;
	//int b = 5;
	//int c = a ^ b;
	//printf("%d", c);
	////^异或，同0异1;

	//没有另设变量的交换法
	//加减法

	//int a = 3;
	//int b = 5;
	//printf("%d\n%d\n", a, b);
	//a = a + b;
	//b = a - b;
	//a = a - b;
	//printf("%d\n%d\n", a, b);
	////原理是先总和a和b,通过相减和赋值的方法，达到交换的手段，如总和为8,那么可以通过给b赋值，
	///*然后用总和减去原来为5的b，达到交换的目的*/
	////缺点就是，如果数据庞大，int整型无法支持就会数据偏差，造成输出错误.即溢出

	////异或法
	//int a = 3;
	//int b = 5;
	//printf("%d\n%d\n", a, b);
	//a = a ^ b;
	//b = a ^ b;
	//a = a ^ b;
	//printf("%d\n%d\n", a, b);
	////^ 抑或相当于一个密码或者钥匙,
	////	这个密码在两个数交换数字时，与一个数配对，就能换出这两个数中的另一个数。
	////	我们不需要知道这个密码是什么，当然编写时要清楚执行时每个数对应的值
	////注意就是如a我们一开始把它作为钥匙，那么就不要急着把它先交换，不然后面没了钥匙就换不回去了
	////这两种方法的核心都是顺序，而这种方法不会溢出，因为本质是二进制的交换！

	//int a = 10;
	//int* p = &a;//取地址
	//*p = 20;//解引用
	//printf("%d", *p);

	//int a = 10;
	//char c = 'r';
	//char* p = &c;
	//int arr[10] = { 0 };
	////sizeof计算变量所占内存空间大小
	//printf("%d\n", sizeof(a));
	//printf("%d\n", sizeof(c));
	//printf("%d\n", sizeof(p));//这个是指针，只可能有4或8
	//
	//printf("%d\n", sizeof(arr));
	//printf("%d\n", sizeof(int [10]));
	////可以用类型代替名字打印

	//short s = 0;//短整型两个字节
	//int a = 10;//整型4个字节
	//printf("%d\n", sizeof(s = a + 5));//放进s，短整型所以为2
	//printf("%d\n", s);//sizeof里面本身不进行运算，所以s =0
	//
	//int a = 0;
	//printf("%d\n", ~a);
	////~按（二进制）位取反
	////00000000000000000000000000000000
	////11111111111111111111111111111111 -补码
	////11111111111111111111111111111110-反码
	////10000000000000000000000000000001-原码
	////-1
	
	
	
	//求补码中有多少个1
	//int num = 0;
	//int count = 0;
	//scanf("%d", &num);
	//while (num)//num非0就进入，0就自动跳出
	//{
	//	if (num % 2 == 1)
	//	{
	//		count++;
	//	}
	//	num = num / 2;//6/2=3，然后跟3的方法同理
	//}
	////此方法就是针对直接输入一个数字来求补码中有多少个1，因为是二进制，所以%2,/2,模拟二进制表达出来
	////==1是因为你要找一，所以要有1出来，%2分离出1，/2去除最后一位！
	////问题就是无法求负数,其实这种方法本质是利用正整数原反补码相等才能用的
	//printf("%d", count);

//int num = 0;
//int count = 0;
//scanf("%d", &num);
//int i = 0;
//for (i = 0; i < 32; i++)
//{
//	/*if (1 == (num >> i) & 1)*///你搞错了，是1和这整个比不是分开来
//	if (1 == ((num >> i) & 1))//二进制位，不是1就是0，所以判断==1
//		count++;
//}
//printf("%d", count);
////00000000000000000000000000001111
////00000000000000000000000000000001
////就是这样一直向右边推进一次一次推1，推2，这样判断有没有1，有1count就会加,这样就算是负数也可以.
////这就是按位与的用处
////a = a & 1;
////a &= 1;//记住按位与是在二进制中实现的
////!逻辑反操作,相当于"非"的意思,真变假，假变真
//int a = 0;
////printf("%d", !a);//这里的1只是系统固定给的值，系统只是目的要达成非0而已.
//if (!a)//这里是判断的意思，意思是判断a这个值是真是假，这里意思就是如果a是假的
//{
//	printf("呵呵");
//}
//if (a)//这里意思就是如果a是真的
//{
//	printf("呵呵");
//}
////因为a=0为假，所以执行上面那条语句.	

int a = 11;
a = a | (1 << 2);
printf("%d\n", a);
a = a & (~(1 << 2));
printf("%d\n", a);
	return 0;
}
